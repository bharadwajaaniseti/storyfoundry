'use client'

import React, { useState, useEffect, useRef, useCallback } from 'react'
import { 
  Plus, Heart, Search, MoreVertical, Trash2, Edit3, Users, 
  ArrowRight, Eye, EyeOff, Filter, X, ChevronDown, ChevronRight,
  Link2, Target, Zap, Crown, Shield, MessageCircle, Flame,
  Save, User, AlertTriangle, CheckCircle, Clock, Calendar,
  GitBranch, Network, BarChart3, TrendingUp, Activity, Grid,
  Layers, Move, RotateCcw, Share2, Download, Upload, Settings,
  Home, Swords, BookOpen, UserCircle, Palette, ZoomIn, ZoomOut,
  Type
} from 'lucide-react'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Textarea } from '@/components/ui/textarea'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { createSupabaseClient } from '@/lib/auth'
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription } from '@/components/ui/dialog'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'
import { Label } from '@/components/ui/label'

// Enhanced CSS styles will be included via Tailwind CSS classes
import { Badge } from '@/components/ui/badge'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { Progress } from '@/components/ui/progress'
import { Separator } from '@/components/ui/separator'
import { cn } from '@/lib/utils'

// Enhanced Custom Components matching site design
interface EnhancedSelectProps {
  value?: string
  onValueChange?: (value: string) => void
  placeholder?: string
  children: React.ReactNode
  className?: string
  triggerClassName?: string
  contentClassName?: string
  customDisplay?: string
  onOpenChange?: (open: boolean) => void
  [key: string]: any
}

const EnhancedSelect = ({ 
  value, 
  onValueChange, 
  placeholder, 
  children, 
  className,
  triggerClassName,
  contentClassName,
  customDisplay,
  ...props 
}: EnhancedSelectProps) => {
  const [isOpen, setIsOpen] = React.useState(false)
  
  return (
    <Select 
      value={value} 
      onValueChange={onValueChange} 
      onOpenChange={setIsOpen}
      {...props}
    >
      <SelectTrigger 
        className={cn(
          "relative bg-white border-2 border-gray-200 rounded-xl shadow-sm px-5 py-4",
          "hover:border-rose-300 focus:border-rose-500 focus:ring-2 focus:ring-rose-100",
          "transition-all duration-300 ease-out text-left overflow-hidden",
          "data-[state=open]:border-rose-500 data-[state=open]:ring-2 data-[state=open]:ring-rose-100",
          "data-[state=open]:shadow-lg",
          "[&>svg]:hidden", // Hide the default chevron
          triggerClassName,
          className
        )}
      >
        <div className="flex-1 pr-8 min-w-0 overflow-hidden">
          {customDisplay ? (
            <span className="text-base font-medium block truncate w-full text-left text-gray-900">
              {customDisplay}
            </span>
          ) : (
            <SelectValue 
              placeholder={placeholder} 
              className="text-base font-medium block truncate w-full text-left" 
            />
          )}
        </div>
        <ChevronDown 
          className={cn(
            "absolute right-5 top-1/2 transform -translate-y-1/2 h-5 w-5 text-gray-500 flex-shrink-0",
            "transition-transform duration-200 pointer-events-none",
            isOpen && "rotate-180"
          )} 
        />
      </SelectTrigger>
      <SelectContent 
        className={cn(
          "bg-white border-2 border-gray-200 rounded-xl shadow-xl p-3 min-w-[300px]",
          "animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95",
          "data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2",
          "data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
          "backdrop-blur-sm max-h-[400px] overflow-y-auto",
          contentClassName
        )}
        sideOffset={6}
      >
        {children}
      </SelectContent>
    </Select>
  )
}

interface EnhancedSelectItemProps {
  children: React.ReactNode
  className?: string
  value: string
  [key: string]: any
}

const EnhancedSelectItem = ({ children, className, ...props }: EnhancedSelectItemProps) => {
  return (
    <SelectItem
      className={cn(
        "relative flex cursor-pointer select-none items-center rounded-xl px-5 py-4 mx-1 my-1.5",
        "text-base outline-none transition-all duration-200",
        "hover:bg-rose-50 hover:text-rose-900 focus:bg-rose-50 focus:text-rose-900",
        "data-[state=checked]:bg-rose-500 data-[state=checked]:text-white",
        "data-[state=checked]:shadow-md min-h-[56px]",
        className
      )}
      {...props}
    >
      <span className="absolute right-4 flex h-5 w-5 items-center justify-center">
        <CheckCircle className="h-4 w-4 opacity-0 data-[state=checked]:opacity-100 transition-opacity duration-200" />
      </span>
      <div className="flex-1 pr-8">
        {children}
      </div>
    </SelectItem>
  )
}

interface EnhancedInputProps extends React.InputHTMLAttributes<HTMLInputElement> {
  className?: string
}

const EnhancedInput = React.forwardRef<HTMLInputElement, EnhancedInputProps>(({ className, ...props }, ref) => {
  return (
    <Input
      ref={ref}
      className={cn(
        "bg-white border-2 border-gray-200 rounded-xl shadow-sm px-5 py-4 text-base",
        "hover:border-rose-300 focus:border-rose-500 focus:ring-2 focus:ring-rose-100",
        "transition-all duration-300 ease-out placeholder:text-gray-400",
        className
      )}
      {...props}
    />
  )
})

EnhancedInput.displayName = "EnhancedInput"

interface EnhancedTextareaProps extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {
  className?: string
}

const EnhancedTextarea = React.forwardRef<HTMLTextAreaElement, EnhancedTextareaProps>(({ className, ...props }, ref) => {
  return (
    <Textarea
      ref={ref}
      className={cn(
        "bg-white border-2 border-gray-200 rounded-xl shadow-sm px-5 py-4 text-base min-h-[120px]",
        "hover:border-rose-300 focus:border-rose-500 focus:ring-2 focus:ring-rose-100",
        "transition-all duration-300 ease-out placeholder:text-gray-400 resize-none",
        className
      )}
      {...props}
    />
  )
})

EnhancedTextarea.displayName = "EnhancedTextarea"

interface EnhancedSliderProps {
  value: number
  onChange: (e: React.ChangeEvent<HTMLInputElement>) => void
  min?: number
  max?: number
  label?: string
  color?: string
  className?: string
  leftLabel?: string
  rightLabel?: string
  [key: string]: any
}

const EnhancedSlider = ({ value, onChange, min = 0, max = 10, label, color = "rose", className, ...props }: EnhancedSliderProps) => {
  return (
    <div className="space-y-3">
      <Input
        type="range"
        min={min}
        max={max}
        value={value}
        onChange={onChange}
        className={cn(
          "w-full h-3 bg-gray-200 rounded-xl appearance-none cursor-pointer",
          "slider-thumb:appearance-none slider-thumb:w-6 slider-thumb:h-6",
          `slider-thumb:bg-${color}-500 slider-thumb:rounded-full slider-thumb:shadow-lg`,
          "slider-thumb:border-4 slider-thumb:border-white slider-thumb:cursor-pointer",
          "hover:bg-gray-300 transition-colors duration-200",
          className
        )}
        {...props}
      />
      <div className="flex justify-between text-sm text-gray-500">
        <span>{props.leftLabel || 'Low'}</span>
        <span className={`font-medium text-${color}-500`}>
          {label ? `${label}: ` : ''}{value}/{max}
        </span>
        <span>{props.rightLabel || 'High'}</span>
      </div>
    </div>
  )
}

interface Relationship {
  id: string
  name: string
  description: string
  attributes: {
    type?: string // romantic, familial, friendship, rivalry, professional, etc.
    strength?: number // 1-10 scale
    status?: string // active, former, complicated, unknown
    dynamics?: string[] // mutual_respect, one_sided, toxic, supportive, etc.
    history?: string
    current_state?: string
    character_1_id?: string
    character_1_name?: string
    character_2_id?: string
    character_2_name?: string
    notes?: string
    // Enhanced Campfire-style features
    timeline_events?: Array<{
      date: string
      event: string
      description: string
      impact_level: 'low' | 'medium' | 'high'
      relationship_change: number // -5 to +5
    }>
    tension_level?: number // 0-10 scale for conflict/tension
    intimacy_level?: number // 0-10 scale for emotional closeness
    dependency_level?: number // 0-10 scale for how much they need each other
    trust_level?: number // 0-10 scale
    respect_level?: number // 0-10 scale
    power_balance?: 'equal' | 'character_1_dominant' | 'character_2_dominant' | 'shifting'
    relationship_arc?: Array<{
      phase: string
      description: string
      chapters: string[]
      key_scenes: string[]
    }>
    conflict_sources?: string[] // money, values, goals, past, secrets, etc.
    bonding_factors?: string[] // shared_experiences, common_goals, mutual_respect, etc.
    relationship_goals?: string // where should this relationship go
    story_importance?: 'primary' | 'secondary' | 'background'
    [key: string]: any
  }
  tags: string[]
  project_id: string
  created_at: string
  updated_at: string
  category: string
}

interface Character {
  id: string
  name: string
  description: string
  category: string
}

interface RelationshipsPanelProps {
  projectId: string
  selectedElement?: any
  onRelationshipsChange?: () => void
  onClearSelection?: () => void
}

const RELATIONSHIP_TYPES = [
  { value: 'romantic', label: 'Romantic', icon: Heart, color: 'rose', description: 'Love, attraction, partnership' },
  { value: 'familial', label: 'Family', icon: Users, color: 'blue', description: 'Blood relations, chosen family' },
  { value: 'friendship', label: 'Friendship', icon: User, color: 'green', description: 'Platonic bonds, companionship' },
  { value: 'rivalry', label: 'Rivalry', icon: Flame, color: 'red', description: 'Competition, antagonism' },
  { value: 'professional', label: 'Professional', icon: Shield, color: 'purple', description: 'Work relationships, business' },
  { value: 'mentorship', label: 'Mentorship', icon: Target, color: 'amber', description: 'Teacher-student, guidance' },
  { value: 'alliance', label: 'Alliance', icon: Link2, color: 'cyan', description: 'Strategic partnerships' },
  { value: 'conflict', label: 'Conflict', icon: Zap, color: 'orange', description: 'Enemies, adversaries' },
  { value: 'hierarchy', label: 'Hierarchy', icon: Crown, color: 'violet', description: 'Power structures, authority' },
  { value: 'dependency', label: 'Dependency', icon: GitBranch, color: 'teal', description: 'One-sided reliance' },
  { value: 'relationship_web', label: 'Visual Web', icon: Network, color: 'indigo', description: 'Canvas-based relationship network' },
  { value: 'other', label: 'Other', icon: MessageCircle, color: 'gray', description: 'Custom relationship type' }
]

const RELATIONSHIP_STATUS = [
  { value: 'developing', label: 'Developing', color: 'blue', description: 'Relationship is forming' },
  { value: 'active', label: 'Active', color: 'green', description: 'Currently engaged relationship' },
  { value: 'strained', label: 'Strained', color: 'yellow', description: 'Under tension or pressure' },
  { value: 'complicated', label: 'Complicated', color: 'orange', description: 'Complex, mixed dynamics' },
  { value: 'former', label: 'Former', color: 'gray', description: 'Past relationship, no longer active' },
  { value: 'broken', label: 'Broken', color: 'red', description: 'Severed or destroyed relationship' },
  { value: 'unknown', label: 'Unknown', color: 'slate', description: 'Status unclear or undefined' },
  { value: 'secret', label: 'Secret', color: 'purple', description: 'Hidden from others' }
]

const RELATIONSHIP_DYNAMICS = [
  'mutual_respect', 'one_sided', 'toxic', 'supportive', 'competitive',
  'protective', 'dependent', 'manipulative', 'inspiring', 'challenging',
  'nurturing', 'conflicted', 'secretive', 'open', 'balanced',
  'volatile', 'stable', 'passionate', 'distant', 'codependent'
]

const CONFLICT_SOURCES = [
  'money', 'values', 'goals', 'past_betrayal', 'secrets', 'jealousy',
  'power', 'resources', 'territory', 'ideology', 'love_triangle',
  'family_honor', 'revenge', 'misunderstanding', 'competition'
]

const BONDING_FACTORS = [
  'shared_trauma', 'common_goals', 'mutual_respect', 'shared_values',
  'complementary_skills', 'similar_background', 'shared_secrets',
  'mutual_protection', 'intellectual_connection', 'emotional_support'
]

const POWER_BALANCE_OPTIONS = [
  { value: 'equal', label: 'Equal Partnership', description: 'Both have equal influence' },
  { value: 'character_1_dominant', label: 'First Character Dominant', description: 'First character has more control' },
  { value: 'character_2_dominant', label: 'Second Character Dominant', description: 'Second character has more control' },
  { value: 'shifting', label: 'Shifting Power', description: 'Power changes based on situation' }
]

const STORY_IMPORTANCE = [
  { value: 'primary', label: 'Primary', color: 'red', description: 'Central to main plot' },
  { value: 'secondary', label: 'Secondary', color: 'amber', description: 'Important subplot element' },
  { value: 'background', label: 'Background', color: 'gray', description: 'Adds depth and context' }
]

// Helper functions for relationship display
function getRelationshipTypeIcon(type: string) {
  const relationshipType = RELATIONSHIP_TYPES.find(t => t.value === type)
  return relationshipType ? relationshipType.icon : Heart
}

function getRelationshipTypeColor(type: string) {
  const relationshipType = RELATIONSHIP_TYPES.find(t => t.value === type)
  return relationshipType ? relationshipType.color : 'gray'
}

function getStatusColor(status: string) {
  const statusObj = RELATIONSHIP_STATUS.find(s => s.value === status)
  return statusObj ? statusObj.color : 'gray'
}

// Component for individual relationship card
const RelationshipCard = React.memo(({ 
  relationship, 
  onEdit, 
  onDelete 
}: { 
  relationship: Relationship
  onEdit: (rel: Relationship) => void
  onDelete: (id: string) => void 
}) => {
  const TypeIcon = getRelationshipTypeIcon(relationship.attributes?.type || '')
  const typeColor = getRelationshipTypeColor(relationship.attributes?.type || '')
  const statusColor = getStatusColor(relationship.attributes?.status || 'active')
  
  return (
    <Card 
      className="hover:shadow-md transition-shadow border border-gray-200 cursor-pointer" 
      onClick={() => onEdit(relationship)}
    >
      <CardHeader className="pb-3">
        <div className="flex items-start justify-between">
          <div className="flex items-center gap-2">
            <TypeIcon className={`w-5 h-5 text-${typeColor}-500`} />
            <div>
              <CardTitle className="text-lg font-semibold truncate">
                {relationship.name}
              </CardTitle>
              <div className="flex items-center gap-2 mt-1">
                <Badge 
                  variant="secondary" 
                  className={`bg-${statusColor}-100 text-${statusColor}-700`}
                >
                  {RELATIONSHIP_STATUS.find(s => s.value === relationship.attributes?.status)?.label || 'Active'}
                </Badge>
                {relationship.attributes?.strength && (
                  <Badge variant="outline">
                    Strength: {relationship.attributes.strength}/10
                  </Badge>
                )}
                {relationship.attributes?.story_importance && (
                  <Badge 
                    variant="outline"
                    className={`bg-${STORY_IMPORTANCE.find(s => s.value === relationship.attributes?.story_importance)?.color}-100`}
                  >
                    {STORY_IMPORTANCE.find(s => s.value === relationship.attributes?.story_importance)?.label}
                  </Badge>
                )}
              </div>
            </div>
          </div>
          <Button
            variant="ghost"
            size="sm"
            onClick={(e) => {
              e.stopPropagation()
              onDelete(relationship.id)
            }}
          >
            <Trash2 className="w-4 h-4 text-red-500" />
          </Button>
        </div>
      </CardHeader>
      <CardContent>
        <div className="space-y-3">
          {/* Characters */}
          <div className="flex items-center justify-between">
            <span className="text-sm font-medium text-blue-600">
              {relationship.attributes?.character_1_name || 'Character 1'}
            </span>
            <ArrowRight className="w-4 h-4 text-gray-400" />
            <span className="text-sm font-medium text-blue-600">
              {relationship.attributes?.character_2_name || 'Character 2'}
            </span>
          </div>

          {/* Enhanced Metrics */}
          <div className="grid grid-cols-3 gap-2 text-xs">
            {relationship.attributes?.tension_level !== undefined && (
              <div className="text-center">
                <div className="text-red-500 font-medium">Tension</div>
                <div>{relationship.attributes.tension_level}/10</div>
              </div>
            )}
            {relationship.attributes?.trust_level !== undefined && (
              <div className="text-center">
                <div className="text-blue-500 font-medium">Trust</div>
                <div>{relationship.attributes.trust_level}/10</div>
              </div>
            )}
            {relationship.attributes?.intimacy_level !== undefined && (
              <div className="text-center">
                <div className="text-purple-500 font-medium">Intimacy</div>
                <div>{relationship.attributes.intimacy_level}/10</div>
              </div>
            )}
          </div>

          {/* Description */}
          {relationship.description && (
            <p className="text-sm text-gray-600 line-clamp-3">
              {relationship.description}
            </p>
          )}

          {/* Dynamics */}
          {relationship.attributes?.dynamics && relationship.attributes.dynamics.length > 0 && (
            <div className="flex flex-wrap gap-1">
              {relationship.attributes.dynamics.slice(0, 3).map((dynamic: string) => (
                <Badge key={dynamic} variant="outline" className="text-xs">
                  {dynamic.replace('_', ' ')}
                </Badge>
              ))}
              {relationship.attributes.dynamics.length > 3 && (
                <Badge variant="outline" className="text-xs">
                  +{relationship.attributes.dynamics.length - 3} more
                </Badge>
              )}
            </div>
          )}

          {/* Actions */}
          <div className="flex justify-between items-center pt-2 border-t">
            <Button
              variant="ghost"
              size="sm"
              onClick={(e) => {
                e.stopPropagation()
                onEdit(relationship)
              }}
            >
              <Edit3 className="w-4 h-4 mr-1" />
              Edit
            </Button>
            <span className="text-xs text-gray-500">
              {new Date(relationship.updated_at).toLocaleDateString()}
            </span>
          </div>
        </div>
      </CardContent>
    </Card>
  )
})

RelationshipCard.displayName = "RelationshipCard"

// Flowchart View Component - Campfire-style visual relationship creation
const FlowchartView = React.memo(({ 
  relationships, 
  characters, 
  onCreateRelationship 
}: { 
  relationships: Relationship[]
  characters: Character[]
  onCreateRelationship: (char1Id: string, char2Id: string) => void
}) => {
  const [selectedCharacter, setSelectedCharacter] = useState<string | null>(null)
  const [hoveredCharacter, setHoveredCharacter] = useState<string | null>(null)
  
  const getCharacterConnections = (characterId: string) => {
    return relationships.filter(r => 
      r.attributes?.character_1_id === characterId || 
      r.attributes?.character_2_id === characterId
    ).length
  }

  const getRelationshipBetween = (char1Id: string, char2Id: string) => {
    return relationships.find(r => 
      (r.attributes?.character_1_id === char1Id && r.attributes?.character_2_id === char2Id) ||
      (r.attributes?.character_1_id === char2Id && r.attributes?.character_2_id === char1Id)
    )
  }

  const renderConnectionLines = () => {
    return relationships.map(relationship => {
      const char1 = characters.find(c => c.id === relationship.attributes?.character_1_id)
      const char2 = characters.find(c => c.id === relationship.attributes?.character_2_id)
      if (!char1 || !char2) return null

      const typeColor = getRelationshipTypeColor(relationship.attributes?.type || '')
      const isConflict = relationship.attributes?.type === 'conflict' || relationship.attributes?.type === 'rivalry'

      return (
        <div key={relationship.id} className="absolute inset-0 pointer-events-none">
          <svg className="w-full h-full">
            <line
              x1="50%"
              y1="50%"
              x2="50%"
              y2="50%"
              stroke={`rgb(var(--${typeColor}-500))`}
              strokeWidth={isConflict ? 3 : 2}
              strokeDasharray={isConflict ? "8,4" : "0"}
              opacity={0.6}
              className="connection-line"
            />
          </svg>
        </div>
      )
    })
  }

  if (characters.length === 0) {
    return (
      <div className="text-center py-16">
        <Users className="w-16 h-16 text-gray-300 mx-auto mb-4" />
        <p className="text-gray-600 text-lg mb-2">No Characters Available</p>
        <p className="text-gray-500 text-sm">
          Create characters first to use the flowchart relationship builder
        </p>
      </div>
    )
  }

  return (
    <div className="bg-gradient-to-br from-rose-50 to-pink-50 rounded-2xl border-2 border-rose-100 p-8 min-h-[600px] relative overflow-hidden">
      {/* Instructions */}
      <div className="absolute top-4 left-4 bg-white/80 backdrop-blur-sm rounded-lg p-3 shadow-sm border border-rose-200">
        <p className="text-sm text-gray-600 mb-1">
          <strong>Flowchart Mode:</strong> Click characters to connect them
        </p>
        <p className="text-xs text-gray-500">
          {selectedCharacter ? 'Now click another character to create a relationship' : 'Select a character to start'}
        </p>
      </div>

      {/* Legend */}
      <div className="absolute top-4 right-4 bg-white/80 backdrop-blur-sm rounded-lg p-3 shadow-sm border border-rose-200">
        <div className="text-sm font-medium text-gray-700 mb-2">Connections</div>
        <div className="space-y-1 text-xs">
          <div className="flex items-center gap-2">
            <div className="w-3 h-0.5 bg-green-500"></div>
            <span>Friendly</span>
          </div>
          <div className="flex items-center gap-2">
            <div className="w-3 h-0.5 bg-red-500 border-dashed"></div>
            <span>Conflict</span>
          </div>
          <div className="flex items-center gap-2">
            <div className="w-3 h-0.5 bg-rose-500"></div>
            <span>Romantic</span>
          </div>
        </div>
      </div>

      {/* Character Nodes */}
      <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-6 gap-6 pt-20">
        {characters.map(character => {
          const isSelected = selectedCharacter === character.id
          const isHovered = hoveredCharacter === character.id
          const connections = getCharacterConnections(character.id)
          const hasConnectionToSelected = selectedCharacter && getRelationshipBetween(selectedCharacter, character.id)
          
          return (
            <div
              key={character.id}
              className="relative flex flex-col items-center group cursor-pointer"
              onClick={() => {
                if (selectedCharacter && selectedCharacter !== character.id) {
                  // Create connection
                  onCreateRelationship(selectedCharacter, character.id)
                  setSelectedCharacter(null)
                } else {
                  setSelectedCharacter(character.id === selectedCharacter ? null : character.id)
                }
              }}
              onMouseEnter={() => setHoveredCharacter(character.id)}
              onMouseLeave={() => setHoveredCharacter(null)}
            >
              {/* Connection indicator */}
              <div className={cn(
                "absolute -top-2 -right-2 w-6 h-6 rounded-full text-xs font-bold flex items-center justify-center",
                connections > 0 ? "bg-rose-500 text-white" : "bg-gray-200 text-gray-500"
              )}>
                {connections}
              </div>
              
              {/* Character Circle */}
              <div className={cn(
                "w-16 h-16 rounded-full flex items-center justify-center font-bold text-xl transition-all duration-300",
                "border-4 shadow-lg hover:shadow-xl transform hover:scale-110",
                isSelected ? "bg-rose-500 text-white border-rose-600 shadow-rose-200 scale-110" :
                hasConnectionToSelected ? "bg-blue-100 border-blue-300 text-blue-700" :
                isHovered ? "bg-rose-100 border-rose-300 text-rose-700" :
                "bg-white border-gray-300 text-gray-700 hover:border-rose-300"
              )}>
                {character.name.charAt(0).toUpperCase()}
              </div>
              
              {/* Character Name */}
              <div className="mt-3 text-center">
                <div className={cn(
                  "font-medium text-sm transition-colors duration-300",
                  isSelected ? "text-rose-600" : "text-gray-700 group-hover:text-rose-600"
                )}>
                  {character.name}
                </div>
                {connections > 0 && (
                  <div className="text-xs text-gray-500">
                    {connections} connection{connections !== 1 ? 's' : ''}
                  </div>
                )}
              </div>
              
              {/* Selection Highlight */}
              {isSelected && (
                <div className="absolute inset-0 rounded-full border-4 border-rose-400 animate-pulse pointer-events-none scale-125"></div>
              )}
              
              {/* Hover Effect */}
              {isHovered && !isSelected && (
                <div className="absolute inset-0 rounded-full bg-rose-100 opacity-20 scale-125 pointer-events-none"></div>
              )}
            </div>
          )
        })}
      </div>

      {/* Connection Lines */}
      {renderConnectionLines()}
      
      {/* Empty State */}
      {relationships.length === 0 && (
        <div className="absolute inset-0 flex items-center justify-center">
          <div className="text-center bg-white/60 backdrop-blur-sm rounded-2xl p-8 border-2 border-dashed border-rose-200">
            <Heart className="w-12 h-12 text-rose-300 mx-auto mb-4" />
            <p className="text-rose-600 font-medium">Start Creating Connections</p>
            <p className="text-rose-500 text-sm">Click on characters to connect them</p>
          </div>
        </div>
      )}
    </div>
  )
})

FlowchartView.displayName = "FlowchartView"

// Network View Component
const NetworkView = React.memo(({ 
  relationships, 
  characters, 
  networkData 
}: { 
  relationships: Relationship[]
  characters: Character[]
  networkData: { nodes: any[], links: any[] }
}) => {
  return (
    <div className="h-96 border rounded-lg bg-gray-50 flex items-center justify-center">
      <div className="text-center">
        <Network className="w-16 h-16 text-gray-300 mx-auto mb-4" />
        <p className="text-gray-600 text-lg mb-2">Network View</p>
        <p className="text-gray-500 text-sm">
          Interactive relationship network visualization coming soon
        </p>
      </div>
    </div>
  )
})

NetworkView.displayName = "NetworkView"

// Matrix View Component
const MatrixView = React.memo(({ 
  characters, 
  relationships, 
  matrix 
}: { 
  characters: Character[]
  relationships: Relationship[]
  matrix: Array<Array<Relationship | null>>
}) => {
  if (characters.length === 0) {
    return (
      <div className="text-center py-12">
        <BarChart3 className="w-16 h-16 text-gray-300 mx-auto mb-4" />
        <p className="text-gray-600">No characters available for matrix view</p>
      </div>
    )
  }

  return (
    <div className="overflow-x-auto">
      <table className="min-w-full border border-gray-200">
        <thead>
          <tr className="bg-gray-50">
            <th className="border border-gray-200 p-2 text-left font-medium">Character</th>
            {characters.map(char => (
              <th key={char.id} className="border border-gray-200 p-2 text-center font-medium min-w-24">
                <div className="truncate" title={char.name}>
                  {char.name.slice(0, 8)}...
                </div>
              </th>
            ))}
          </tr>
        </thead>
        <tbody>
          {characters.map((char1, i) => (
            <tr key={char1.id}>
              <td className="border border-gray-200 p-2 font-medium bg-gray-50">
                {char1.name}
              </td>
              {characters.map((char2, j) => {
                const relationship = matrix[i][j]
                const isSelf = i === j
                
                return (
                  <td key={char2.id} className="border border-gray-200 p-1 text-center">
                    {isSelf ? (
                      <div className="w-6 h-6 bg-gray-200 rounded mx-auto"></div>
                    ) : relationship ? (
                      <div 
                        className={`w-6 h-6 rounded mx-auto bg-${getRelationshipTypeColor(relationship.attributes?.type || '')}-500`}
                        title={`${relationship.name} (${relationship.attributes?.type})`}
                      ></div>
                    ) : (
                      <div className="w-6 h-6 border border-gray-300 rounded mx-auto bg-white"></div>
                    )}
                  </td>
                )
              })}
            </tr>
          ))}
        </tbody>
      </table>
      
      {/* Legend */}
      <div className="mt-4 flex flex-wrap gap-4 text-sm">
        <div className="flex items-center gap-2">
          <div className="w-4 h-4 bg-gray-200 rounded"></div>
          <span>Self</span>
        </div>
        <div className="flex items-center gap-2">
          <div className="w-4 h-4 border border-gray-300 rounded bg-white"></div>
          <span>No relationship</span>
        </div>
        {RELATIONSHIP_TYPES.slice(0, 5).map(type => (
          <div key={type.value} className="flex items-center gap-2">
            <div className={`w-4 h-4 bg-${type.color}-500 rounded`}></div>
            <span>{type.label}</span>
          </div>
        ))}
      </div>
    </div>
  )
})

MatrixView.displayName = "MatrixView"

// Timeline View Component
const TimelineView = React.memo(({ relationships }: { relationships: Relationship[] }) => {
  const relationshipsWithEvents = relationships.filter(r => 
    r.attributes?.timeline_events && r.attributes.timeline_events.length > 0
  )

  if (relationshipsWithEvents.length === 0) {
    return (
      <div className="text-center py-12">
        <Activity className="w-16 h-16 text-gray-300 mx-auto mb-4" />
        <p className="text-gray-600 text-lg mb-2">No timeline events</p>
        <p className="text-gray-500 text-sm">
          Add timeline events to your relationships to see their development over time
        </p>
      </div>
    )
  }

  return (
    <div className="space-y-6">
      {relationshipsWithEvents.map(relationship => (
        <Card key={relationship.id} className="p-4">
          <h3 className="font-semibold mb-3 flex items-center gap-2">
            <Heart className="w-4 h-4 text-rose-500" />
            {relationship.name}
          </h3>
          <div className="space-y-2">
            {relationship.attributes?.timeline_events?.map((event, index) => (
              <div key={index} className="flex items-start gap-3 p-2 bg-gray-50 rounded">
                <div className="text-xs text-gray-500 min-w-20">{event.date}</div>
                <div className="flex-1">
                  <div className="font-medium text-sm">{event.event}</div>
                  {event.description && (
                    <div className="text-sm text-gray-600">{event.description}</div>
                  )}
                </div>
              </div>
            ))}
          </div>
        </Card>
      ))}
    </div>
  )
})

TimelineView.displayName = "TimelineView"

const RelationshipsPanel = ({ 
  projectId, 
  selectedElement, 
  onRelationshipsChange,
  onClearSelection 
}: RelationshipsPanelProps) => {
  const [relationships, setRelationships] = useState<Relationship[]>([])
  const [characters, setCharacters] = useState<Character[]>([])
  const [loading, setLoading] = useState(true)
  const [searchTerm, setSearchTerm] = useState('')
  const [selectedType, setSelectedType] = useState<string>('all')
  const [selectedStatus, setSelectedStatus] = useState<string>('all')
  const [showCreateDialog, setShowCreateDialog] = useState(false)
  const [editingRelationship, setEditingRelationship] = useState<Relationship | null>(null)
  const [viewMode, setViewMode] = useState<'grid' | 'network' | 'matrix' | 'timeline' | 'flowchart'>('grid')
  const [activeTab, setActiveTab] = useState<'overview' | 'dynamics' | 'timeline' | 'analysis'>('overview')
  const [showFlowchartDialog, setShowFlowchartDialog] = useState(false)
  const [selectedCharacters, setSelectedCharacters] = useState<string[]>([])
  const [flowchartStep, setFlowchartStep] = useState<'select' | 'connect' | 'define'>('select')
  
  // Quick Connect Dialog state
  const [showQuickConnect, setShowQuickConnect] = useState(false)
  const [quickConnectChar1, setQuickConnectChar1] = useState<string>('')
  const [quickConnectChar2, setQuickConnectChar2] = useState<string>('')
  const [quickConnectType, setQuickConnectType] = useState<string>('friendship')
  const [quickConnectIntensity, setQuickConnectIntensity] = useState<number>(5)
  
  // Canvas-based relationship creation state
  const [showNameInput, setShowNameInput] = useState(false)
  const [relationshipName, setRelationshipName] = useState('')
  const [showCanvas, setShowCanvas] = useState(false) // New state for canvas creation interface
  
  const networkRef = useRef<HTMLDivElement>(null)
  
  // Enhanced form state for Campfire-style features
  const [formData, setFormData] = useState({
    name: '',
    description: '',
    type: '',
    strength: 5,
    status: 'active',
    character_1_id: '',
    character_2_id: '',
    dynamics: [] as string[],
    history: '',
    current_state: '',
    notes: '',
    // Enhanced fields
    tension_level: 0,
    intimacy_level: 5,
    dependency_level: 0,
    trust_level: 5,
    respect_level: 5,
    power_balance: 'equal' as 'equal' | 'character_1_dominant' | 'character_2_dominant' | 'shifting',
    conflict_sources: [] as string[],
    bonding_factors: [] as string[],
    relationship_goals: '',
    story_importance: 'secondary' as 'primary' | 'secondary' | 'background'
  })

  const supabase = createSupabaseClient()

  useEffect(() => {
    loadRelationships()
    loadCharacters()
  }, [projectId])

  useEffect(() => {
    if (selectedElement && selectedElement.category === 'relationships') {
      console.log('ðŸŽ¯ SELECTED ELEMENT: Opening canvas for:', selectedElement.name)
      // Always open canvas for any relationship
      setRelationshipName(selectedElement.name)
      setEditingRelationship(selectedElement)
      setShowCanvas(true)
    }
    
    // Cleanup function to prevent memory leaks
    return () => {
      if (selectedElement && selectedElement.category === 'relationships') {
        console.log('ðŸ§¹ CLEANUP: Clearing relationship selection')
      }
    }
  }, [selectedElement])

  // Listen for canvas relationship events from sidebar
  useEffect(() => {
    const handleOpenRelationshipCanvas = (event: any) => {
      console.log('ðŸŽ¯ RECEIVED openRelationshipCanvas event:', event.detail?.relationship?.name)
      const relationship = event.detail.relationship
      
      // Always open canvas for any relationship
      if (relationship) {
        console.log('ðŸŽ¯ OPENING CANVAS from event')
        setRelationshipName(relationship.name)
        setEditingRelationship(relationship)
        setShowCanvas(true)
      }
    }

    window.addEventListener('openRelationshipCanvas', handleOpenRelationshipCanvas)
    return () => {
      window.removeEventListener('openRelationshipCanvas', handleOpenRelationshipCanvas)
    }
  }, [])

  const loadRelationships = async () => {
    try {
      const { data, error } = await supabase
        .from('world_elements')
        .select('*')
        .eq('project_id', projectId)
        .eq('category', 'relationships')
        .order('created_at', { ascending: false })

      if (error) throw error
      setRelationships(data || [])
    } catch (error) {
      console.error('Error loading relationships:', error)
    } finally {
      setLoading(false)
    }
  }

  const loadCharacters = async () => {
    try {
      const { data, error } = await supabase
        .from('world_elements')
        .select('id, name, description, category')
        .eq('project_id', projectId)
        .eq('category', 'characters')
        .order('name')

      if (error) throw error
      setCharacters(data || [])
    } catch (error) {
      console.error('Error loading characters:', error)
    }
  }

  const filteredRelationships = relationships.filter(relationship => {
    const matchesSearch = !searchTerm || 
      relationship.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
      relationship.description.toLowerCase().includes(searchTerm.toLowerCase()) ||
      relationship.attributes?.character_1_name?.toLowerCase().includes(searchTerm.toLowerCase()) ||
      relationship.attributes?.character_2_name?.toLowerCase().includes(searchTerm.toLowerCase())
    
    const matchesType = selectedType === 'all' || !selectedType || relationship.attributes?.type === selectedType
    const matchesStatus = selectedStatus === 'all' || !selectedStatus || relationship.attributes?.status === selectedStatus
    
    return matchesSearch && matchesType && matchesStatus
  })

  const handleCreateRelationship = async () => {
    try {
      const character1 = characters.find(c => c.id === formData.character_1_id)
      const character2 = characters.find(c => c.id === formData.character_2_id)

      if (!character1 || !character2) {
        console.error('Missing character selection:', { character1: !!character1, character2: !!character2 })
        alert('Please select both characters for the relationship')
        return
      }

      const relationshipData = {
        project_id: projectId,
        category: 'relationships',
        name: formData.name || `${character1.name} & ${character2.name}`,
        description: formData.description,
        attributes: {
          type: formData.type,
          strength: formData.strength,
          status: formData.status,
          character_1_id: formData.character_1_id,
          character_1_name: character1.name,
          character_2_id: formData.character_2_id,
          character_2_name: character2.name,
          dynamics: formData.dynamics,
          history: formData.history,
          current_state: formData.current_state,
          notes: formData.notes,
          // Enhanced Campfire-style fields
          tension_level: formData.tension_level,
          intimacy_level: formData.intimacy_level,
          dependency_level: formData.dependency_level,
          trust_level: formData.trust_level,
          respect_level: formData.respect_level,
          power_balance: formData.power_balance,
          conflict_sources: formData.conflict_sources,
          bonding_factors: formData.bonding_factors,
          relationship_goals: formData.relationship_goals,
          story_importance: formData.story_importance,
          timeline_events: []
        },
        tags: []
      }

      let result: Relationship
      if (editingRelationship) {
        const { data, error } = await supabase
          .from('world_elements')
          .update({ ...relationshipData, updated_at: new Date().toISOString() })
          .eq('id', editingRelationship.id)
          .select()
          .single()

        if (error) {
          console.error('Update error:', error)
          throw new Error(`Failed to update relationship: ${error.message}`)
        }
        result = data as Relationship

        setRelationships(prev => prev.map(r => r.id === editingRelationship.id ? result : r))
      } else {
        const { data, error } = await supabase
          .from('world_elements')
          .insert(relationshipData)
          .select()
          .single()

        if (error) {
          console.error('Insert error:', error)
          throw new Error(`Failed to create relationship: ${error.message}`)
        }
        result = data as Relationship

        setRelationships(prev => [result, ...prev])
      }

      // Broadcast change
      window.dispatchEvent(new CustomEvent('relationshipCreated', { 
        detail: { relationship: result, projectId } 
      }))

      setShowCreateDialog(false)
      setEditingRelationship(null)
      resetForm()
      onRelationshipsChange?.()
    } catch (error) {
      console.error('Error creating/updating relationship:', error)
      // Show user-friendly error message
      alert(error instanceof Error ? error.message : 'An unexpected error occurred while saving the relationship')
    }
  }

  const handleDeleteRelationship = async (id: string) => {
    if (!confirm('Are you sure you want to delete this relationship?')) return

    try {
      const { error } = await supabase
        .from('world_elements')
        .delete()
        .eq('id', id)

      if (error) throw error

      setRelationships(prev => prev.filter(r => r.id !== id))
      onRelationshipsChange?.()
    } catch (error) {
      console.error('Error deleting relationship:', error)
    }
  }

  // Quick Connect handler for flowchart-style relationship creation
  const handleQuickConnect = async (char1Id?: string, char2Id?: string) => {
    const character1Id = char1Id || quickConnectChar1
    const character2Id = char2Id || quickConnectChar2
    
    if (!character1Id || !character2Id) return
    
    const character1 = characters.find(c => c.id === character1Id)
    const character2 = characters.find(c => c.id === character2Id)
    
    if (!character1 || !character2) return
    
    try {
      const relationshipData = {
        project_id: projectId,
        category: 'relationships',
        name: `${character1.name} & ${character2.name}`,
        type: 'character',
        attributes: {
          name: `${character1.name} & ${character2.name}`,
          type: char1Id ? 'friendship' : quickConnectType,
          strength: char1Id ? 5 : quickConnectIntensity,
          status: 'active',
          character_1_id: character1Id,
          character_2_id: character2Id,
          description: `${char1Id ? 'friendship' : quickConnectType} relationship`,
          dynamics: [],
          history: '',
          current_state: 'developing',
          notes: '',
          tension_level: (char1Id ? 'friendship' : quickConnectType) === 'conflict' ? 7 : (char1Id ? 'friendship' : quickConnectType) === 'rivalry' ? 5 : 2,
          intimacy_level: (char1Id ? 'friendship' : quickConnectType) === 'romance' ? 8 : (char1Id ? 'friendship' : quickConnectType) === 'family' ? 7 : 5,
          dependency_level: (char1Id ? 5 : quickConnectIntensity) >= 7 ? 6 : 3,
          trust_level: (char1Id ? 'friendship' : quickConnectType) === 'conflict' ? 2 : (char1Id ? 'friendship' : quickConnectType) === 'rivalry' ? 4 : 7,
          respect_level: (char1Id ? 5 : quickConnectIntensity) >= 6 ? 7 : 5,
          power_balance: 'equal',
          conflict_sources: [],
          bonding_factors: [],
          relationship_goals: [],
          story_importance: 'moderate',
          timeline_events: []
        },
        tags: []
      }

      const { data, error } = await supabase
        .from('world_elements')
        .insert(relationshipData)
        .select()
        .single()

      if (error) throw error
      const result = data as Relationship

      setRelationships(prev => [result, ...prev])
      
      // Broadcast change
      window.dispatchEvent(new CustomEvent('relationshipCreated', { 
        detail: { relationship: result, projectId } 
      }))

      if (!char1Id) {
        // Reset dialog if opened from Quick Connect
        setShowQuickConnect(false)
        setQuickConnectChar1('')
        setQuickConnectChar2('')
        setQuickConnectType('friendship')
        setQuickConnectIntensity(5)
      }
      
      onRelationshipsChange?.()
    } catch (error) {
      console.error('Error creating relationship:', error)
    }
  }

  // Handle saving canvas-based relationship
  const handleSaveCanvasRelationship = async (canvasData: { nodes: CanvasNode[], connections: CanvasConnection[] }) => {
    try {
      const supabase = createSupabaseClient()
      
      // Debug logging
      console.log('Canvas save debug:', {
        relationshipName,
        projectId,
        editingRelationship: editingRelationship?.id,
        canvasDataNodes: canvasData?.nodes?.length || 0,
        canvasDataConnections: canvasData?.connections?.length || 0,
        canvasData
      })
      
      // Validate required data
      if (!projectId) {
        console.error('No projectId provided')
        return
      }
      
      if (!canvasData || !canvasData.nodes || !canvasData.connections) {
        console.error('Invalid canvas data:', canvasData)
        return
      }
      
      // Generate a name if none is provided
      const webName = relationshipName?.trim() || (editingRelationship?.name) || `Relationship Web - ${new Date().toLocaleDateString()}`
      
      // Create the relationship web data
      const relationshipWebData = {
        name: webName,
        description: `Visual relationship web showing connections between ${canvasData.nodes.length} elements`,
        category: 'relationships',
        project_id: projectId,
        attributes: {
          type: 'relationship_web',
          canvas_data: canvasData,
          created_at: editingRelationship?.attributes?.created_at || new Date().toISOString(),
          updated_at: new Date().toISOString()
        },
        tags: ['relationship', 'visual', 'canvas']
      }

      console.log('Relationship web object:', JSON.stringify(relationshipWebData, null, 2))

      let data: any, error: any

      if (editingRelationship) {
        // Update existing relationship
        const updateResult = await supabase
          .from('world_elements')
          .update(relationshipWebData)
          .eq('id', editingRelationship.id)
          .select()
          .single()
        
        data = updateResult.data
        error = updateResult.error
        
        if (!error && data) {
          // Update the relationships list
          setRelationships(prev => prev.map(r => r.id === editingRelationship.id ? data : r))
        }
      } else {
        // Create new relationship
        const insertResult = await supabase
          .from('world_elements')
          .insert(relationshipWebData)
          .select()
          .single()
        
        data = insertResult.data
        error = insertResult.error
        
        if (!error && data) {
          // Add to relationships list
          setRelationships(prev => [data, ...prev])
        }
      }

      if (error) {
        console.error('Error saving relationship web:', JSON.stringify(error, null, 2))
        console.error('Attempted to save:', JSON.stringify(relationshipWebData, null, 2))
        return
      }

      if (!data) {
        console.error('No data returned from relationship web insert')
        console.error('Insert result - data:', data, 'error:', error)
        return
      }

      const savedRelationshipWeb = data

      // Refresh the relationships list
      await loadRelationships()
      
      // Broadcast change for sidebar update
      if (editingRelationship) {
        window.dispatchEvent(new CustomEvent('relationshipUpdated', { 
          detail: { relationship: savedRelationshipWeb, projectId } 
        }))
      } else {
        window.dispatchEvent(new CustomEvent('relationshipCreated', { 
          detail: { relationship: savedRelationshipWeb, projectId } 
        }))
      }

      // Clear editing state
      setEditingRelationship(null)
      
      onRelationshipsChange?.()
    } catch (error) {
      console.error('Error saving canvas relationship:', error)
    }
  }

  const resetForm = () => {
    setFormData({
      name: '',
      description: '',
      type: '',
      strength: 5,
      status: 'active',
      character_1_id: '',
      character_2_id: '',
      dynamics: [],
      history: '',
      current_state: '',
      notes: '',
      // Enhanced fields
      tension_level: 0,
      intimacy_level: 5,
      dependency_level: 0,
      trust_level: 5,
      respect_level: 5,
      power_balance: 'equal',
      conflict_sources: [],
      bonding_factors: [],
      relationship_goals: '',
      story_importance: 'secondary'
    })
  }

  // Network view helpers
  const generateNetworkData = useCallback(() => {
    const nodes = characters.map(character => ({
      id: character.id,
      name: character.name,
      type: 'character',
      connections: relationships.filter(r => 
        r.attributes?.character_1_id === character.id || 
        r.attributes?.character_2_id === character.id
      ).length
    }))

    const links = relationships.map(relationship => ({
      source: relationship.attributes?.character_1_id,
      target: relationship.attributes?.character_2_id,
      type: relationship.attributes?.type,
      strength: relationship.attributes?.strength || 5,
      tension: relationship.attributes?.tension_level || 0,
      status: relationship.attributes?.status,
      relationship: relationship
    })).filter(link => link.source && link.target)

    return { nodes, links }
  }, [characters, relationships])

  // Character relationship matrix
  const generateMatrix = useCallback(() => {
    const matrix: Array<Array<Relationship | null>> = []
    
    characters.forEach((char1, i) => {
      matrix[i] = []
      characters.forEach((char2, j) => {
        if (i === j) {
          matrix[i][j] = null // Same character
        } else {
          const relationship = relationships.find(r => 
            (r.attributes?.character_1_id === char1.id && r.attributes?.character_2_id === char2.id) ||
            (r.attributes?.character_1_id === char2.id && r.attributes?.character_2_id === char1.id)
          )
          matrix[i][j] = relationship || null
        }
      })
    })
    
    return matrix
  }, [characters, relationships])

  // Analytics calculations
  const relationshipAnalytics = useCallback(() => {
    const totalRelationships = relationships.length
    const activeRelationships = relationships.filter(r => r.attributes?.status === 'active').length
    const conflictRelationships = relationships.filter(r => 
      r.attributes?.type === 'conflict' || r.attributes?.type === 'rivalry'
    ).length
    const romanticRelationships = relationships.filter(r => r.attributes?.type === 'romantic').length
    
    const avgTension = relationships.reduce((sum, r) => sum + (r.attributes?.tension_level || 0), 0) / totalRelationships || 0
    const avgIntimacy = relationships.reduce((sum, r) => sum + (r.attributes?.intimacy_level || 0), 0) / totalRelationships || 0
    
    const mostConnectedCharacter = characters.reduce((max, char) => {
      const connections = relationships.filter(r => 
        r.attributes?.character_1_id === char.id || r.attributes?.character_2_id === char.id
      ).length
      return connections > max.connections ? { character: char, connections } : max
    }, { character: null as Character | null, connections: 0 })

    return {
      totalRelationships,
      activeRelationships,
      conflictRelationships,
      romanticRelationships,
      avgTension: Math.round(avgTension * 10) / 10,
      avgIntimacy: Math.round(avgIntimacy * 10) / 10,
      mostConnectedCharacter
    }
  }, [relationships, characters])

  if (loading) {
    return (
      <div className="h-full bg-white p-6 overflow-y-auto">
        <div className="max-w-5xl mx-auto">
          <div className="animate-pulse">
            <div className="h-8 bg-gray-200 rounded w-48 mb-4"></div>
            <div className="space-y-4">
              {[...Array(3)].map((_, i) => (
                <div key={i} className="h-32 bg-gray-100 rounded-lg"></div>
              ))}
            </div>
          </div>
        </div>
      </div>
    )
  }

  // Show canvas full-screen when creating a new relationship
  if (showCanvas) {
    return (
      <div className="h-full bg-white">
        <InlineRelationshipCanvas
          relationshipName={relationshipName}
          characters={characters}
          existingRelationship={editingRelationship}
          projectId={projectId}
          relationships={relationships}
          setRelationships={setRelationships}
          onClose={() => {
            setShowCanvas(false)
            setRelationshipName('')
          }}
          onSave={async (canvasData: { nodes: CanvasNode[], connections: CanvasConnection[] }) => {
            await handleSaveCanvasRelationship(canvasData)
            setShowCanvas(false)
            setRelationshipName('')
          }}
        />
      </div>
    )
  }

  return (
    <div className="h-full bg-white p-6 overflow-y-auto">
      <div className="max-w-5xl mx-auto">
        {/* Header */}
        <div className="flex items-center justify-between mb-6">
          <div>
            <h2 className="text-2xl font-bold text-gray-900 flex items-center gap-2">
              <Heart className="w-7 h-7 text-rose-500" />
              Relationships
            </h2>
            <p className="text-sm text-gray-500">Map connections, dynamics, and story arcs between characters</p>
          </div>
          <div className="flex items-center gap-2">
            {/* View Mode Toggle */}
            <div className="flex items-center bg-gray-100 rounded-lg p-1">
              <Button
                variant={viewMode === 'grid' ? 'default' : 'ghost'}
                size="sm"
                onClick={() => setViewMode('grid')}
                className="text-xs px-3"
              >
                <Grid className="w-4 h-4 mr-1" />
                Grid
              </Button>
              <Button
                variant={viewMode === 'flowchart' ? 'default' : 'ghost'}
                size="sm"
                onClick={() => setViewMode('flowchart')}
                className={cn(
                  "text-xs px-3 transition-all duration-200",
                  viewMode === 'flowchart' ? "bg-purple-600 text-white" : "hover:bg-purple-50"
                )}
                title="Interactive Flowchart - Click characters to connect (Classic mode)"
              >
                <GitBranch className="w-4 h-4 mr-1" />
                Flow
              </Button>
              <Button
                variant={viewMode === 'network' ? 'default' : 'ghost'}
                size="sm"
                onClick={() => setViewMode('network')}
                className="text-xs px-3"
              >
                <Network className="w-4 h-4 mr-1" />
                Network
              </Button>
              <Button
                variant={viewMode === 'matrix' ? 'default' : 'ghost'}
                size="sm"
                onClick={() => setViewMode('matrix')}
                className="text-xs px-3"
              >
                <BarChart3 className="w-4 h-4 mr-1" />
                Matrix
              </Button>
              <Button
                variant={viewMode === 'timeline' ? 'default' : 'ghost'}
                size="sm"
                onClick={() => setViewMode('timeline')}
                className="text-xs px-3"
              >
                <Activity className="w-4 h-4 mr-1" />
                Timeline
              </Button>
            </div>
            
            {/* Create Buttons */}
            <div className="flex gap-2">
              <Button
                variant="outline"
                onClick={() => {
                  setShowQuickConnect(true)
                }}
                className="border-rose-200 text-rose-600 hover:bg-rose-50"
              >
                <Zap className="w-4 h-4 mr-2" />
                Quick Connect
              </Button>
              {!showNameInput ? (
                <Button
                  onClick={() => setShowNameInput(true)}
                  className="bg-gradient-to-r from-rose-500 to-pink-500 hover:from-rose-600 hover:to-pink-600 text-white shadow-lg"
                >
                  <Plus className="w-4 h-4 mr-2" />
                  New Relationship
                </Button>
              ) : (
                <div className="flex items-center gap-3">
                  <EnhancedInput
                    placeholder="Enter relationship name..."
                    value={relationshipName}
                    onChange={(e: React.ChangeEvent<HTMLInputElement>) => setRelationshipName(e.target.value)}
                    onKeyDown={(e: React.KeyboardEvent<HTMLInputElement>) => {
                      if (e.key === 'Enter' && relationshipName.trim()) {
                        setShowCanvas(true)
                        setShowNameInput(false)
                      } else if (e.key === 'Escape') {
                        setShowNameInput(false)
                        setRelationshipName('')
                      }
                    }}
                    className="min-w-[300px]"
                    autoFocus
                  />
                  <Button
                    onClick={() => {
                      if (relationshipName.trim()) {
                        setShowCanvas(true)
                        setShowNameInput(false)
                      }
                    }}
                    disabled={!relationshipName.trim()}
                    className="bg-gradient-to-r from-rose-500 to-pink-500 hover:from-rose-600 hover:to-pink-600 text-white shadow-lg"
                  >
                    <ArrowRight className="w-4 h-4" />
                  </Button>
                  <Button
                    variant="outline"
                    onClick={() => {
                      setShowNameInput(false)
                      setRelationshipName('')
                    }}
                    className="border-gray-300 hover:border-gray-400"
                  >
                    <X className="w-4 h-4" />
                  </Button>
                </div>
              )}
            </div>
          </div>
        </div>

        {/* Filters */}
        <div className="flex flex-wrap items-center gap-4 mb-6 p-4 bg-gray-50 rounded-lg">
          <div className="flex-1 min-w-64">
            <Input
              placeholder="Search relationships..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              className="bg-white"
            />
          </div>
          <Select value={selectedType} onValueChange={setSelectedType}>
            <SelectTrigger className="w-48 bg-white">
              <SelectValue placeholder="Filter by type" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="all">All Types</SelectItem>
              {RELATIONSHIP_TYPES.map(type => (
                <SelectItem key={type.value} value={type.value}>
                  <div className="flex items-center gap-2">
                    <type.icon className="w-4 h-4" />
                    {type.label}
                  </div>
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
          <Select value={selectedStatus} onValueChange={setSelectedStatus}>
            <SelectTrigger className="w-48 bg-white">
              <SelectValue placeholder="Filter by status" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="all">All Statuses</SelectItem>
              {RELATIONSHIP_STATUS.map(status => (
                <SelectItem key={status.value} value={status.value}>
                  <div className="flex items-center gap-2">
                    <div className={`w-2 h-2 rounded-full bg-${status.color}-500`}></div>
                    {status.label}
                  </div>
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        </div>

        {/* Content */}
        {filteredRelationships.length === 0 ? (
          <div className="text-center py-12">
            <Heart className="w-16 h-16 text-gray-300 mx-auto mb-4" />
            <p className="text-gray-600 text-lg mb-2">No relationships yet</p>
            <p className="text-gray-500 mb-6">
              Start mapping the connections between your characters to bring depth to your story.
            </p>
            <Button 
              onClick={() => {
                setRelationshipName("First Relationship")
                setShowCanvas(true)
              }}
              className="bg-rose-500 hover:bg-rose-600 text-white"
            >
              <Plus className="w-4 h-4 mr-2" />
              Create First Relationship
            </Button>
          </div>
        ) : (
          <>
            {/* Analytics Dashboard */}
            {viewMode === 'grid' && (
              <div className="mb-8 grid grid-cols-2 md:grid-cols-4 gap-4">
                {(() => {
                  const analytics = relationshipAnalytics()
                  return (
                    <>
                      <Card className="p-4">
                        <div className="flex items-center gap-2 mb-2">
                          <Heart className="w-5 h-5 text-rose-500" />
                          <span className="text-sm font-medium">Total</span>
                        </div>
                        <div className="text-2xl font-bold">{analytics.totalRelationships}</div>
                        <div className="text-xs text-gray-500">{analytics.activeRelationships} active</div>
                      </Card>
                      
                      <Card className="p-4">
                        <div className="flex items-center gap-2 mb-2">
                          <Flame className="w-5 h-5 text-red-500" />
                          <span className="text-sm font-medium">Conflicts</span>
                        </div>
                        <div className="text-2xl font-bold">{analytics.conflictRelationships}</div>
                        <div className="text-xs text-gray-500">Tension avg: {analytics.avgTension}/10</div>
                      </Card>
                      
                      <Card className="p-4">
                        <div className="flex items-center gap-2 mb-2">
                          <Heart className="w-5 h-5 text-pink-500" />
                          <span className="text-sm font-medium">Romance</span>
                        </div>
                        <div className="text-2xl font-bold">{analytics.romanticRelationships}</div>
                        <div className="text-xs text-gray-500">Intimacy avg: {analytics.avgIntimacy}/10</div>
                      </Card>
                      
                      <Card className="p-4">
                        <div className="flex items-center gap-2 mb-2">
                          <Network className="w-5 h-5 text-blue-500" />
                          <span className="text-sm font-medium">Hub</span>
                        </div>
                        <div className="text-lg font-bold truncate">
                          {analytics.mostConnectedCharacter.character?.name || 'None'}
                        </div>
                        <div className="text-xs text-gray-500">
                          {analytics.mostConnectedCharacter.connections} connections
                        </div>
                      </Card>
                    </>
                  )
                })()}
              </div>
            )}

            {/* Flowchart Mode Tip */}
            {viewMode === 'grid' && relationships.length > 0 && (
              <div className="mb-6 bg-gradient-to-r from-purple-50 to-blue-50 border border-purple-200 rounded-xl p-4">
                <div className="flex items-center gap-3">
                  <div className="flex-shrink-0">
                    <GitBranch className="w-8 h-8 text-purple-600" />
                  </div>
                  <div className="flex-1">
                    <h3 className="font-medium text-purple-900 mb-1">
                      💡 Try Flowchart Mode
                    </h3>
                    <p className="text-sm text-purple-700">
                      Click the <strong>Flow</strong> button above to see your characters as interactive circles. 
                      Click any two characters to instantly create connections - no dragging needed!
                    </p>
                  </div>
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => setViewMode('flowchart')}
                    className="border-purple-300 text-purple-700 hover:bg-purple-100"
                  >
                    Try It
                  </Button>
                </div>
              </div>
            )}

            {/* View Content */}
            {viewMode === 'grid' && (
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                {filteredRelationships.map(relationship => (
                  <RelationshipCard
                    key={relationship.id}
                    relationship={relationship}
                    onEdit={(rel) => {
                      console.log('ðŸŽ¯ CARD CLICK: Opening canvas for:', rel.name)
                      // Always open canvas for any relationship
                      setRelationshipName(rel.name)
                      setEditingRelationship(rel)
                      setShowCanvas(true)
                    }}
                    onDelete={handleDeleteRelationship}
                  />
                ))}
              </div>
            )}

            {viewMode === 'flowchart' && (
              <FlowchartView 
                relationships={filteredRelationships} 
                characters={characters}
                onCreateRelationship={handleQuickConnect}
              />
            )}

            {viewMode === 'network' && (
              <NetworkView 
                relationships={filteredRelationships} 
                characters={characters}
                networkData={generateNetworkData()}
              />
            )}

            {viewMode === 'matrix' && (
              <MatrixView 
                characters={characters} 
                relationships={relationships}
                matrix={generateMatrix()}
              />
            )}

            {viewMode === 'timeline' && (
              <TimelineView relationships={filteredRelationships} />
            )}
          </>
        )}

        <Dialog open={showCreateDialog} onOpenChange={(open) => {
          setShowCreateDialog(open)
          if (!open) {
            setEditingRelationship(null)
            resetForm()
            onClearSelection?.()
          }
        }}>
          <DialogContent className="!max-w-none w-[90vw] max-h-[90vh] overflow-y-auto bg-white border-rose-200 shadow-2xl rounded-3xl">
            <DialogHeader className="pb-6 border-b border-rose-100">
              <DialogTitle className="text-2xl font-bold bg-gradient-to-r from-rose-600 to-pink-600 bg-clip-text text-transparent flex items-center gap-3">
                <div className="w-8 h-8 rounded-full bg-gradient-to-r from-rose-500 to-pink-500 flex items-center justify-center">
                  <Heart className="w-4 h-4 text-white" />
                </div>
                {editingRelationship ? 'Edit Relationship' : 'Create New Relationship'}
              </DialogTitle>
              <DialogDescription className="text-gray-600 mt-2 text-base">
                Define the connection, dynamics, and story arc between two characters to bring depth to your story.
              </DialogDescription>
            </DialogHeader>

            <Tabs value={activeTab} onValueChange={(value) => setActiveTab(value as any)} className="w-full mt-6">
              <TabsList className="grid w-full grid-cols-4 bg-rose-50 border border-rose-200 rounded-2xl p-1 h-14">
                <TabsTrigger 
                  value="overview" 
                  className="rounded-xl data-[state=active]:bg-white data-[state=active]:text-rose-600 data-[state=active]:shadow-md font-medium transition-all duration-300"
                >
                  <User className="w-4 h-4 mr-2" />
                  Overview
                </TabsTrigger>
                <TabsTrigger 
                  value="dynamics" 
                  className="rounded-xl data-[state=active]:bg-white data-[state=active]:text-rose-600 data-[state=active]:shadow-md font-medium transition-all duration-300"
                >
                  <Activity className="w-4 h-4 mr-2" />
                  Dynamics
                </TabsTrigger>
                <TabsTrigger 
                  value="timeline" 
                  className="rounded-xl data-[state=active]:bg-white data-[state=active]:text-rose-600 data-[state=active]:shadow-md font-medium transition-all duration-300"
                >
                  <Calendar className="w-4 h-4 mr-2" />
                  Timeline
                </TabsTrigger>
                <TabsTrigger 
                  value="analysis" 
                  className="rounded-xl data-[state=active]:bg-white data-[state=active]:text-rose-600 data-[state=active]:shadow-md font-medium transition-all duration-300"
                >
                  <BarChart3 className="w-4 h-4 mr-2" />
                  Analysis
                </TabsTrigger>
              </TabsList>

              {/* Overview Tab */}
              <TabsContent value="overview" className="space-y-8 py-6">
                {/* Character Selection */}
                <div className="bg-white rounded-2xl p-6 border border-rose-100 shadow-sm">
                  <h3 className="text-lg font-semibold text-gray-800 mb-4 flex items-center gap-2">
                    <Users className="w-5 h-5 text-rose-500" />
                    Characters
                  </h3>
                  <div className="grid grid-cols-2 gap-6">
                    <div>
                      <Label htmlFor="character_1" className="text-sm font-medium text-gray-700 mb-2 block">First Character</Label>
                      <EnhancedSelect value={formData.character_1_id} onValueChange={(value: string) => 
                        setFormData(prev => ({ ...prev, character_1_id: value }))
                      }>
                          {characters.map(character => (
                            <EnhancedSelectItem key={character.id} value={character.id}>
                              <div className="flex items-center gap-3">
                                <div className="w-8 h-8 bg-rose-100 rounded-full flex items-center justify-center text-sm font-medium text-rose-700">
                                  {character.name.charAt(0).toUpperCase()}
                                </div>
                                {character.name}
                              </div>
                            </EnhancedSelectItem>
                          ))}
                      </EnhancedSelect>
                    </div>
                    <div>
                      <Label htmlFor="character_2" className="text-sm font-medium text-gray-700 mb-2 block">Second Character</Label>
                      <EnhancedSelect value={formData.character_2_id} onValueChange={(value: string) => 
                        setFormData(prev => ({ ...prev, character_2_id: value }))
                      }>
                          {characters.map(character => (
                            <EnhancedSelectItem key={character.id} value={character.id}>
                              <div className="flex items-center gap-3">
                                <div className="w-8 h-8 bg-rose-100 rounded-full flex items-center justify-center text-sm font-medium text-rose-700">
                                  {character.name.charAt(0).toUpperCase()}
                                </div>
                                {character.name}
                              </div>
                            </EnhancedSelectItem>
                          ))}
                      </EnhancedSelect>
                    </div>
                  </div>
                </div>

                {/* Basic Info */}
                <div className="bg-white rounded-2xl p-6 border border-rose-100 shadow-sm space-y-6">
                  <h3 className="text-lg font-semibold text-gray-800 mb-4 flex items-center gap-2">
                    <Heart className="w-5 h-5 text-rose-500" />
                    Basic Information
                  </h3>
                  <div>
                    <Label htmlFor="name" className="text-sm font-medium text-gray-700 mb-2 block">Relationship Name (Optional)</Label>
                    <EnhancedInput
                      id="name"
                      value={formData.name}
                      onChange={(e: React.ChangeEvent<HTMLInputElement>) => setFormData(prev => ({ ...prev, name: e.target.value }))}
                      placeholder="Auto-generated if left blank"
                      className="h-12"
                    />
                  </div>

                  <div>
                    <Label htmlFor="description" className="text-sm font-medium text-gray-700 mb-2 block">Description</Label>
                    <EnhancedTextarea
                      id="description"
                      value={formData.description}
                      onChange={(e: React.ChangeEvent<HTMLTextAreaElement>) => setFormData(prev => ({ ...prev, description: e.target.value }))}
                      placeholder="Describe the nature of this relationship..."
                      rows={3}
                      className="resize-none"
                    />
                  </div>
                </div>

                {/* Type and Status */}
                <div className="bg-white rounded-2xl p-6 border border-rose-100 shadow-sm">
                  <h3 className="text-lg font-semibold text-gray-800 mb-4 flex items-center gap-2">
                    <Settings className="w-5 h-5 text-rose-500" />
                    Settings & Status
                  </h3>
                  <div className="grid grid-cols-3 gap-6">
                    <div>
                      <Label htmlFor="type" className="text-sm font-medium text-gray-700 mb-2 block">Relationship Type</Label>
                      <EnhancedSelect value={formData.type} onValueChange={(value: string) => 
                        setFormData(prev => ({ ...prev, type: value }))
                      }>
                          {RELATIONSHIP_TYPES.map(type => (
                            <EnhancedSelectItem key={type.value} value={type.value}>
                              <div className="flex items-center gap-2">
                                <type.icon className="w-4 h-4" />
                                {type.label}
                              </div>
                            </EnhancedSelectItem>
                          ))}
                      </EnhancedSelect>
                    </div>
                    <div>
                      <Label htmlFor="status" className="text-sm font-medium text-gray-700 mb-2 block">Status</Label>
                      <EnhancedSelect value={formData.status} onValueChange={(value: string) => 
                        setFormData(prev => ({ ...prev, status: value }))
                      }>
                          {RELATIONSHIP_STATUS.map(status => (
                            <EnhancedSelectItem key={status.value} value={status.value}>
                              {status.label}
                            </EnhancedSelectItem>
                          ))}
                      </EnhancedSelect>
                    </div>
                    <div>
                      <Label htmlFor="story_importance" className="text-sm font-medium text-gray-700 mb-2 block">Story Importance</Label>
                      <EnhancedSelect value={formData.story_importance} onValueChange={(value: string) => 
                        setFormData(prev => ({ ...prev, story_importance: value as any }))
                      }>
                          {STORY_IMPORTANCE.map(importance => (
                            <EnhancedSelectItem key={importance.value} value={importance.value}>
                              <div className="flex items-center gap-2">
                                <div className={`w-2 h-2 rounded-full bg-${importance.color}-500`}></div>
                                {importance.label}
                              </div>
                            </EnhancedSelectItem>
                          ))}
                      </EnhancedSelect>
                    </div>
                  </div>

                  {/* Power Balance */}
                  <div className="mt-6">
                    <Label htmlFor="power_balance" className="text-sm font-medium text-gray-700 mb-2 block">Power Balance</Label>
                    <EnhancedSelect value={formData.power_balance} onValueChange={(value: string) => 
                      setFormData(prev => ({ ...prev, power_balance: value as any }))
                    }>
                        {POWER_BALANCE_OPTIONS.map(option => (
                          <EnhancedSelectItem key={option.value} value={option.value}>
                            <div>
                              <div className="font-medium">{option.label}</div>
                              <div className="text-sm text-gray-500">{option.description}</div>
                            </div>
                          </EnhancedSelectItem>
                        ))}
                    </EnhancedSelect>
                  </div>
                </div>
              </TabsContent>

              {/* Dynamics Tab */}
              <TabsContent value="dynamics" className="space-y-6 py-4">
                {/* Relationship Metrics */}
                <div className="grid grid-cols-2 gap-6">
                  {/* Left Column */}
                  <div className="space-y-4">
                    {/* Tension Level */}
                    <div>
                      <Label htmlFor="tension_level">Tension Level (0-10)</Label>
                      <Input
                        id="tension_level"
                        type="range"
                        min="0"
                        max="10"
                        value={formData.tension_level}
                        onChange={(e) => setFormData(prev => ({ ...prev, tension_level: parseInt(e.target.value) }))}
                        className="mt-2"
                      />
                      <div className="flex justify-between text-sm text-gray-500 mt-1">
                        <span>Peaceful</span>
                        <span className="font-medium text-red-500">{formData.tension_level}/10</span>
                        <span>Explosive</span>
                      </div>
                    </div>

                    {/* Trust Level */}
                    <div>
                      <Label htmlFor="trust_level">Trust Level (0-10)</Label>
                      <Input
                        id="trust_level"
                        type="range"
                        min="0"
                        max="10"
                        value={formData.trust_level}
                        onChange={(e) => setFormData(prev => ({ ...prev, trust_level: parseInt(e.target.value) }))}
                        className="mt-2"
                      />
                      <div className="flex justify-between text-sm text-gray-500 mt-1">
                        <span>None</span>
                        <span className="font-medium text-blue-500">{formData.trust_level}/10</span>
                        <span>Complete</span>
                      </div>
                    </div>

                    {/* Respect Level */}
                    <div>
                      <Label htmlFor="respect_level">Respect Level (0-10)</Label>
                      <Input
                        id="respect_level"
                        type="range"
                        min="0"
                        max="10"
                        value={formData.respect_level}
                        onChange={(e) => setFormData(prev => ({ ...prev, respect_level: parseInt(e.target.value) }))}
                        className="mt-2"
                      />
                      <div className="flex justify-between text-sm text-gray-500 mt-1">
                        <span>Disdain</span>
                        <span className="font-medium text-green-500">{formData.respect_level}/10</span>
                        <span>Admiration</span>
                      </div>
                    </div>
                  </div>

                  {/* Right Column */}
                  <div className="space-y-4">
                    {/* Intimacy Level */}
                    <div>
                      <Label htmlFor="intimacy_level">Intimacy Level (0-10)</Label>
                      <Input
                        id="intimacy_level"
                        type="range"
                        min="0"
                        max="10"
                        value={formData.intimacy_level}
                        onChange={(e) => setFormData(prev => ({ ...prev, intimacy_level: parseInt(e.target.value) }))}
                        className="mt-2"
                      />
                      <div className="flex justify-between text-sm text-gray-500 mt-1">
                        <span>Strangers</span>
                        <span className="font-medium text-purple-500">{formData.intimacy_level}/10</span>
                        <span>Soul Mates</span>
                      </div>
                    </div>

                    {/* Dependency Level */}
                    <div>
                      <Label htmlFor="dependency_level">Dependency Level (0-10)</Label>
                      <Input
                        id="dependency_level"
                        type="range"
                        min="0"
                        max="10"
                        value={formData.dependency_level}
                        onChange={(e) => setFormData(prev => ({ ...prev, dependency_level: parseInt(e.target.value) }))}
                        className="mt-2"
                      />
                      <div className="flex justify-between text-sm text-gray-500 mt-1">
                        <span>Independent</span>
                        <span className="font-medium text-orange-500">{formData.dependency_level}/10</span>
                        <span>Codependent</span>
                      </div>
                    </div>

                    {/* Strength (overall) */}
                    <div>
                      <Label htmlFor="strength">Relationship Strength (1-10)</Label>
                      <Input
                        id="strength"
                        type="range"
                        min="1"
                        max="10"
                        value={formData.strength}
                        onChange={(e) => setFormData(prev => ({ ...prev, strength: parseInt(e.target.value) }))}
                        className="mt-2"
                      />
                      <div className="flex justify-between text-sm text-gray-500 mt-1">
                        <span>Weak</span>
                        <span className="font-medium">{formData.strength}/10</span>
                        <span>Unbreakable</span>
                      </div>
                    </div>
                  </div>
                </div>

                <Separator />

                {/* Dynamics */}
                <div>
                  <Label>Relationship Dynamics</Label>
                  <div className="grid grid-cols-4 gap-2 mt-2">
                    {RELATIONSHIP_DYNAMICS.map(dynamic => (
                      <label key={dynamic} className="flex items-center space-x-2 text-sm">
                        <input
                          type="checkbox"
                          checked={formData.dynamics.includes(dynamic)}
                          onChange={(e) => {
                            if (e.target.checked) {
                              setFormData(prev => ({ 
                                ...prev, 
                                dynamics: [...prev.dynamics, dynamic] 
                              }))
                            } else {
                              setFormData(prev => ({ 
                                ...prev, 
                                dynamics: prev.dynamics.filter(d => d !== dynamic) 
                              }))
                            }
                          }}
                          className="rounded border-gray-300"
                        />
                        <span>{dynamic.replace('_', ' ')}</span>
                      </label>
                    ))}
                  </div>
                </div>

                <div className="grid grid-cols-2 gap-4">
                  {/* Conflict Sources */}
                  <div>
                    <Label>Sources of Conflict</Label>
                    <div className="grid grid-cols-2 gap-2 mt-2">
                      {CONFLICT_SOURCES.map(source => (
                        <label key={source} className="flex items-center space-x-2 text-sm">
                          <input
                            type="checkbox"
                            checked={formData.conflict_sources.includes(source)}
                            onChange={(e) => {
                              if (e.target.checked) {
                                setFormData(prev => ({ 
                                  ...prev, 
                                  conflict_sources: [...prev.conflict_sources, source] 
                                }))
                              } else {
                                setFormData(prev => ({ 
                                  ...prev, 
                                  conflict_sources: prev.conflict_sources.filter(s => s !== source) 
                                }))
                              }
                            }}
                            className="rounded border-gray-300"
                          />
                          <span>{source.replace('_', ' ')}</span>
                        </label>
                      ))}
                    </div>
                  </div>

                  {/* Bonding Factors */}
                  <div>
                    <Label>Bonding Factors</Label>
                    <div className="grid grid-cols-2 gap-2 mt-2">
                      {BONDING_FACTORS.map(factor => (
                        <label key={factor} className="flex items-center space-x-2 text-sm">
                          <input
                            type="checkbox"
                            checked={formData.bonding_factors.includes(factor)}
                            onChange={(e) => {
                              if (e.target.checked) {
                                setFormData(prev => ({ 
                                  ...prev, 
                                  bonding_factors: [...prev.bonding_factors, factor] 
                                }))
                              } else {
                                setFormData(prev => ({ 
                                  ...prev, 
                                  bonding_factors: prev.bonding_factors.filter(f => f !== factor) 
                                }))
                              }
                            }}
                            className="rounded border-gray-300"
                          />
                          <span>{factor.replace('_', ' ')}</span>
                        </label>
                      ))}
                    </div>
                  </div>
                </div>
              </TabsContent>

              {/* Timeline Tab */}
              <TabsContent value="timeline" className="space-y-6 py-4">
                <div className="text-center py-12">
                  <Calendar className="w-16 h-16 text-gray-300 mx-auto mb-4" />
                  <p className="text-gray-600 text-lg mb-2">Timeline Events</p>
                  <p className="text-gray-500 text-sm mb-6">
                    Track how this relationship develops over time
                  </p>
                  <Button variant="outline">
                    <Plus className="w-4 h-4 mr-2" />
                    Add Timeline Event
                  </Button>
                </div>
              </TabsContent>

              {/* Analysis Tab */}
              <TabsContent value="analysis" className="space-y-6 py-4">
                <div className="space-y-4">
                  <div>
                    <Label htmlFor="relationship_goals">Relationship Goals & Arc</Label>
                    <Textarea
                      id="relationship_goals"
                      value={formData.relationship_goals}
                      onChange={(e) => setFormData(prev => ({ ...prev, relationship_goals: e.target.value }))}
                      placeholder="Where should this relationship go? What's the intended arc?"
                      rows={3}
                    />
                  </div>

                  <div>
                    <Label htmlFor="history">Relationship History</Label>
                    <Textarea
                      id="history"
                      value={formData.history}
                      onChange={(e) => setFormData(prev => ({ ...prev, history: e.target.value }))}
                      placeholder="How did this relationship develop over time?"
                      rows={3}
                    />
                  </div>

                  <div>
                    <Label htmlFor="current_state">Current State</Label>
                    <Textarea
                      id="current_state"
                      value={formData.current_state}
                      onChange={(e) => setFormData(prev => ({ ...prev, current_state: e.target.value }))}
                      placeholder="What's the current state of this relationship?"
                      rows={2}
                    />
                  </div>

                  <div>
                    <Label htmlFor="notes">Additional Notes</Label>
                    <Textarea
                      id="notes"
                      value={formData.notes}
                      onChange={(e) => setFormData(prev => ({ ...prev, notes: e.target.value }))}
                      placeholder="Any other notes about this relationship..."
                      rows={2}
                    />
                  </div>
                </div>
              </TabsContent>
            </Tabs>

            <div className="flex justify-end gap-3 pt-6 border-t border-rose-100 bg-gradient-to-r from-rose-50/50 to-pink-50/50 -mx-6 -mb-6 px-6 pb-6 mt-6 rounded-b-3xl">
              <Button 
                variant="outline" 
                onClick={() => {
                  setShowCreateDialog(false)
                  setEditingRelationship(null)
                  resetForm()
                  onClearSelection?.()
                }}
                className="border-gray-200 text-gray-600 hover:bg-gray-50 h-12 px-6 rounded-xl font-medium"
              >
                <X className="w-4 h-4 mr-2" />
                Cancel
              </Button>
              <Button 
                onClick={handleCreateRelationship}
                className="bg-gradient-to-r from-rose-500 to-pink-600 hover:from-rose-600 hover:to-pink-700 text-white shadow-lg hover:shadow-xl h-12 px-8 rounded-xl font-medium transition-all duration-300"
                disabled={!formData.character_1_id || !formData.character_2_id}
              >
                <Save className="w-4 h-4 mr-2" />
                {editingRelationship ? 'Update' : 'Create'} Relationship
              </Button>
            </div>
          </DialogContent>
        </Dialog>

        {/* Quick Connect Dialog */}
        <Dialog open={showQuickConnect} onOpenChange={setShowQuickConnect}>
          <DialogContent className="max-w-lg bg-white border-rose-200 shadow-2xl rounded-3xl">
            <DialogHeader className="pb-6 border-b border-rose-100">
              <DialogTitle className="text-xl font-bold bg-gradient-to-r from-rose-600 to-pink-600 bg-clip-text text-transparent flex items-center gap-3">
                <div className="w-8 h-8 rounded-full bg-gradient-to-r from-rose-500 to-pink-500 flex items-center justify-center">
                  <Zap className="w-4 h-4 text-white" />
                </div>
                Quick Connect Characters
              </DialogTitle>
              <DialogDescription className="text-gray-600 mt-2">
                Create a relationship between two characters instantly
              </DialogDescription>
            </DialogHeader>

            <div className="space-y-6 py-4">
              {/* Character Selection */}
              <div className="bg-white rounded-2xl p-6 border border-rose-100 shadow-sm">
                <h3 className="text-lg font-semibold text-gray-800 mb-4 flex items-center gap-2">
                  <Users className="w-5 h-5 text-rose-500" />
                  Select Characters
                </h3>
                <div className="grid grid-cols-2 gap-4">
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-2">First Character</label>
                    <EnhancedSelect value={quickConnectChar1} onValueChange={setQuickConnectChar1}>
                      {characters.map(character => (
                        <EnhancedSelectItem key={character.id} value={character.id}>
                          <div className="flex items-center gap-2">
                            <div className="w-6 h-6 bg-rose-100 rounded-full flex items-center justify-center text-xs font-medium text-rose-700">
                              {character.name.charAt(0).toUpperCase()}
                            </div>
                            {character.name}
                          </div>
                        </EnhancedSelectItem>
                      ))}
                  </EnhancedSelect>
                </div>

                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-2">Second Character</label>
                  <EnhancedSelect value={quickConnectChar2} onValueChange={setQuickConnectChar2}>
                      {characters.filter(c => c.id !== quickConnectChar1).map(character => (
                        <EnhancedSelectItem key={character.id} value={character.id}>
                          <div className="flex items-center gap-2">
                            <div className="w-6 h-6 bg-rose-100 rounded-full flex items-center justify-center text-xs font-medium text-rose-700">
                              {character.name.charAt(0).toUpperCase()}
                            </div>
                            {character.name}
                          </div>
                        </EnhancedSelectItem>
                      ))}
                  </EnhancedSelect>
                </div>
              </div>
              </div>

              {/* Relationship Type */}
              <div className="bg-white rounded-2xl p-6 border border-rose-100 shadow-sm">
                <h3 className="text-lg font-semibold text-gray-800 mb-4 flex items-center gap-2">
                  <Heart className="w-5 h-5 text-rose-500" />
                  Relationship Details
                </h3>
                <div className="space-y-4">
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-2">Relationship Type</label>
                    <EnhancedSelect value={quickConnectType} onValueChange={setQuickConnectType}>
                    <EnhancedSelectItem value="friendship">
                      <div className="flex items-center gap-2">
                        <Users className="w-4 h-4 text-green-500" />
                        Friendship
                      </div>
                    </EnhancedSelectItem>
                    <EnhancedSelectItem value="romance">
                      <div className="flex items-center gap-2">
                        <Heart className="w-4 h-4 text-rose-500" />
                        Romance
                      </div>
                    </EnhancedSelectItem>
                    <EnhancedSelectItem value="family">
                      <div className="flex items-center gap-2">
                        <Home className="w-4 h-4 text-blue-500" />
                        Family
                      </div>
                    </EnhancedSelectItem>
                    <EnhancedSelectItem value="rivalry">
                      <div className="flex items-center gap-2">
                        <Swords className="w-4 h-4 text-orange-500" />
                        Rivalry
                      </div>
                    </EnhancedSelectItem>
                    <EnhancedSelectItem value="conflict">
                      <div className="flex items-center gap-2">
                        <Shield className="w-4 h-4 text-red-500" />
                        Conflict
                      </div>
                    </EnhancedSelectItem>
                    <EnhancedSelectItem value="mentor">
                      <div className="flex items-center gap-2">
                        <BookOpen className="w-4 h-4 text-purple-500" />
                        Mentor
                      </div>
                    </EnhancedSelectItem>
                </EnhancedSelect>
              </div>

              {/* Intensity Slider */}
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Relationship Intensity: {quickConnectIntensity}/10
                </label>
                <Input
                  type="range"
                  min={1}
                  max={10}
                  step={1}
                  value={quickConnectIntensity}
                  onChange={(e) => setQuickConnectIntensity(parseInt(e.target.value))}
                  className="w-full"
                />
                <div className="flex justify-between text-xs text-gray-500 mt-1">
                  <span>Weak</span>
                  <span>Strong</span>
                </div>
              </div>
              </div>
            </div>
            </div>

            <div className="flex justify-end gap-3 pt-6 border-t border-rose-100 bg-gradient-to-r from-rose-50/50 to-pink-50/50 -mx-6 -mb-6 px-6 pb-6 mt-6 rounded-b-3xl">
              <Button 
                variant="outline" 
                onClick={() => setShowQuickConnect(false)}
                className="border-gray-200 text-gray-600 hover:bg-gray-50 h-12 px-6 rounded-xl font-medium"
              >
                <X className="w-4 h-4 mr-2" />
                Cancel
              </Button>
              <Button 
                onClick={() => handleQuickConnect()}
                className="bg-gradient-to-r from-rose-500 to-pink-600 hover:from-rose-600 hover:to-pink-700 text-white shadow-lg hover:shadow-xl h-12 px-8 rounded-xl font-medium transition-all duration-300"
                disabled={!quickConnectChar1 || !quickConnectChar2}
              >
                <Zap className="w-4 h-4 mr-2" />
                Quick Connect
              </Button>
            </div>
          </DialogContent>
        </Dialog>
      </div>
    </div>
  )
}

// Canvas-based interfaces
interface CanvasNode {
  id: string
  type: 'character' | 'location' | 'item' | 'concept'
  name: string
  x: number
  y: number
  width: number
  height: number
  color?: string
  imageUrl?: string
}

interface CanvasConnection {
  id: string
  fromNodeId: string
  toNodeId: string
  label: string
  type: string
  color: string
  textColor?: string
  hasArrow: boolean
  hasReverseArrow?: boolean
  arrowSize?: number
  reverseArrowSize?: number
  arrowColor?: string
  reverseArrowColor?: string
  isDirectional: boolean
  strokeWidth?: number
  strokeDasharray?: string | null
}

// Full Canvas Component with Move Tool - Enhanced Visual Style
const InlineRelationshipCanvas = ({ 
  relationshipName, 
  characters, 
  existingRelationship, 
  projectId,
  relationships,
  setRelationships,
  onClose, 
  onSave, 
  ...props 
}: {
  relationshipName: string
  characters: any[]
  existingRelationship?: any
  projectId: string
  relationships: any[]
  setRelationships: (updater: (prev: any[]) => any[]) => void
  onClose: () => void
  onSave: (data: any) => void
}) => {
  const [nodes, setNodes] = useState<CanvasNode[]>([])
  const [connections, setConnections] = useState<CanvasConnection[]>([])
  const [selectedNode, setSelectedNode] = useState<string | null>(null)
  const [selectedConnection, setSelectedConnection] = useState<string | null>(null)
  const [editingConnection, setEditingConnection] = useState<string | null>(null)
  const [isConnecting, setIsConnecting] = useState(false)
  const [connectionStart, setConnectionStart] = useState<string | null>(null)
  const [isDragging, setIsDragging] = useState(false)
  const [dragStart, setDragStart] = useState({ x: 0, y: 0 })
  const [canvasOffset, setCanvasOffset] = useState({ x: 0, y: 0 })
  const [scale, setScale] = useState(1)
  const [showElementsPanel, setShowElementsPanel] = useState(true)
  const [showPropertiesPanel, setShowPropertiesPanel] = useState(false)
  const [isPanning, setIsPanning] = useState(false)
  const [panStart, setPanStart] = useState({ x: 0, y: 0 })
  const [moveToolActive, setMoveToolActive] = useState(false)
  const [animationSpeed, setAnimationSpeed] = useState(3) // Animation duration in seconds
  const [showAnimations, setShowAnimations] = useState(true) // Toggle for animations
  const [isSyncing, setIsSyncing] = useState(false) // Syncing status
  
  const canvasRef = useRef<HTMLDivElement>(null)

  // Initialize canvas with existing relationship data
  useEffect(() => {
    console.log('🔍 DEBUG - Initializing canvas with existing relationship data:', existingRelationship?.canvas_data)
    if (existingRelationship?.canvas_data) {
      try {
        const canvasData = JSON.parse(existingRelationship.canvas_data)
        console.log('🔍 DEBUG - Parsed canvas data:', canvasData)
        if (canvasData.nodes) {
          console.log('🔍 DEBUG - Setting nodes:', canvasData.nodes)
          setNodes(canvasData.nodes)
        }
        if (canvasData.connections) {
          console.log('🔍 DEBUG - Setting connections:', canvasData.connections)
          setConnections(canvasData.connections)
        }
      } catch (error) {
        console.error('Failed to parse existing canvas data:', error)
      }
    }
  }, [existingRelationship])

  // Load existing relationships as connections when characters are added
  useEffect(() => {
    const loadExistingConnections = () => {
      console.log('🔍 DEBUG - Loading existing connections from relationships:', relationships.length)
      const newConnections: CanvasConnection[] = []
      
      // Convert existing relationships to canvas connections
      relationships.forEach(rel => {
        console.log('🔍 DEBUG - Processing relationship:', rel.id, rel.attributes)
        const char1Id = rel.attributes?.character_1_id
        const char2Id = rel.attributes?.character_2_id
        
        if (char1Id && char2Id) {
          const char1OnCanvas = nodes.find(n => n.id === char1Id)
          const char2OnCanvas = nodes.find(n => n.id === char2Id)
          
          console.log('🔍 DEBUG - Character check:', { char1Id, char2Id, char1OnCanvas: !!char1OnCanvas, char2OnCanvas: !!char2OnCanvas })
          
          if (char1OnCanvas && char2OnCanvas) {
            // Only add if connection doesn't already exist
            const connectionExists = connections.some(conn => 
              (conn.fromNodeId === char1Id && conn.toNodeId === char2Id) ||
              (conn.fromNodeId === char2Id && conn.toNodeId === char1Id)
            )
            
            if (!connectionExists) {
              const newConnection = {
                id: `rel-${rel.id}`,
                fromNodeId: char1Id,
                toNodeId: char2Id,
                label: rel.attributes?.relationship_type || rel.attributes?.type || 'Related',
                type: rel.attributes?.type || 'relationship',
                color: rel.attributes?.type === 'conflict' ? '#dc2626' : '#f43f5e',
                hasArrow: true,
                isDirectional: false,
                strokeWidth: 2
              }
              console.log('🔍 DEBUG - Adding new connection:', newConnection)
              newConnections.push(newConnection)
            } else {
              console.log('🔍 DEBUG - Connection already exists for:', char1Id, char2Id)
            }
          }
        } else {
          console.log('🔍 DEBUG - Missing character IDs in relationship:', rel.id, { char1Id, char2Id })
        }
      })
      
      console.log('🔍 DEBUG - New connections to add:', newConnections.length, newConnections)
      if (newConnections.length > 0) {
        setConnections(prev => {
          console.log('🔍 DEBUG - Setting connections from', prev.length, 'to', prev.length + newConnections.length)
          return [...prev, ...newConnections]
        })
      }
    }

    if (nodes.length > 0) {
      console.log('🔍 DEBUG - Nodes available, loading connections...', nodes.length)
      loadExistingConnections()
    } else {
      console.log('🔍 DEBUG - No nodes available yet')
    }
  }, [nodes, relationships]) // Re-run when nodes change

  // Keyboard shortcuts
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        setIsConnecting(false)
        setConnectionStart(null)
        setSelectedNode(null)
        setSelectedConnection(null)
        setMoveToolActive(false)
      } else if (e.key === 'Delete' && selectedNode) {
        deleteNode(selectedNode)
      } else if (e.key === 'Delete' && selectedConnection) {
        deleteConnection(selectedConnection)
      } else if (e.key === 'c' && e.ctrlKey) {
        e.preventDefault()
        toggleConnectionMode()
      } else if (e.key === 'm' && e.ctrlKey) {
        e.preventDefault()
        setMoveToolActive(!moveToolActive)
      }
    }

    window.addEventListener('keydown', handleKeyDown)
    return () => window.removeEventListener('keydown', handleKeyDown)
  }, [selectedNode, selectedConnection, moveToolActive])

  // Debug connections and nodes
  useEffect(() => {
    console.log('🔍 DEBUG - Nodes:', nodes.length, nodes)
    console.log('🔍 DEBUG - Connections:', connections.length, connections)
  }, [nodes, connections])

  // Handle canvas panning with Move tool, Shift+Left click, or Right click
  const handleCanvasMouseDown = (e: React.MouseEvent) => {
    const shouldPan = e.button === 2 || (e.button === 0 && e.shiftKey) || (e.button === 0 && moveToolActive)
    
    if (shouldPan) {
      const target = e.target as Element
      const clickedOnCanvas = target === e.currentTarget || target.closest('svg') || target.closest('.absolute.inset-0')
      
      if (clickedOnCanvas) {
        e.preventDefault()
        setIsPanning(true)
        setPanStart({ x: e.clientX, y: e.clientY })
        setSelectedNode(null)
      }
    }
  }

  const handleMouseMove = (e: React.MouseEvent) => {
    if (isDragging && selectedNode) {
      const deltaX = e.clientX - dragStart.x
      const deltaY = e.clientY - dragStart.y
      
      setNodes(prev => prev.map(node => 
        node.id === selectedNode 
          ? { ...node, x: node.x + deltaX / scale, y: node.y + deltaY / scale }
          : node
      ))
      
      setDragStart({ x: e.clientX, y: e.clientY })
    } else if (isPanning) {
      const deltaX = e.clientX - panStart.x
      const deltaY = e.clientY - panStart.y
      
      setCanvasOffset(prev => ({
        x: prev.x + deltaX / scale,
        y: prev.y + deltaY / scale
      }))
      
      setPanStart({ x: e.clientX, y: e.clientY })
    }
  }

  const handleMouseUp = (e: React.MouseEvent) => {
    if (e.button === 2 || e.button === 0) {
      setIsPanning(false)
    }
    setIsDragging(false)
  }

  // Add character to canvas
  const addCharacterToCanvas = (character: any) => {
    // Check if character is already on canvas
    if (nodes.find(node => node.id === character.id)) {
      return
    }
    
    const newNode: CanvasNode = {
      id: character.id,
      type: 'character',
      name: character.name,
      x: Math.random() * 400 + 100,
      y: Math.random() * 300 + 100,
      width: 150,
      height: 80,
      color: '#f43f5e',
      imageUrl: undefined
    }
    setNodes(prev => [...prev, newNode])
  }

  // Delete node from canvas
  const deleteNode = (nodeId: string) => {
    setNodes(prev => prev.filter(node => node.id !== nodeId))
    // Also remove any connections involving this node
    setConnections(prev => prev.filter(conn => conn.fromNodeId !== nodeId && conn.toNodeId !== nodeId))
    setSelectedNode(null)
  }

  // Handle node click for connections
  const handleNodeClick = (nodeId: string, e: React.MouseEvent) => {
    e.stopPropagation()
    
    if (isConnecting && connectionStart && connectionStart !== nodeId) {
      // Create new connection
      const newConnection: CanvasConnection = {
        id: `${connectionStart}-${nodeId}-${Date.now()}`,
        fromNodeId: connectionStart,
        toNodeId: nodeId,
        type: 'relationship',
        label: 'Connected',
        color: '#f43f5e',
        hasArrow: true,
        isDirectional: false,
        strokeWidth: 2
      }
      setConnections(prev => [...prev, newConnection])
      setIsConnecting(false)
      setConnectionStart(null)
    } else if (isConnecting) {
      // Start connection from this node
      setConnectionStart(nodeId)
    } else {
      // Regular selection
      setSelectedNode(nodeId)
    }
  }

  // Delete connection
  const deleteConnection = (connectionId: string) => {
    setConnections(prev => prev.filter(conn => conn.id !== connectionId))
    setSelectedConnection(null)
  }

  // Handle node dragging
  const handleNodeMouseDown = (nodeId: string, e: React.MouseEvent) => {
    if (e.button === 0 && !isConnecting) { // Only start dragging on left click and not in connecting mode
      e.stopPropagation()
      setSelectedNode(nodeId)
      setIsDragging(true)
      setDragStart({ x: e.clientX, y: e.clientY })
    }
  }

  // Toggle connection mode
  const toggleConnectionMode = () => {
    setIsConnecting(!isConnecting)
    setConnectionStart(null)
    setSelectedNode(null)
  }

  // Update connection properties
  const updateConnectionProperties = (connectionId: string, updates: Partial<CanvasConnection>) => {
    setConnections(prev => prev.map(conn => 
      conn.id === connectionId ? { ...conn, ...updates } : conn
    ))
  }

  // Toggle properties panel
  const togglePropertiesPanel = () => {
    setShowPropertiesPanel(!showPropertiesPanel)
  }

  // Canvas controls
  const zoomIn = () => setScale(prev => Math.min(prev * 1.2, 3))
  const zoomOut = () => setScale(prev => Math.max(prev / 1.2, 0.3))
  const resetZoom = () => setScale(1)
  const fitToScreen = () => {
    setScale(1)
    setCanvasOffset({ x: 0, y: 0 })
    setIsPanning(false)
    setPanStart({ x: 0, y: 0 })
  }

  const handleSave = async () => {
    const canvasData = { nodes, connections }
    
    // Also create actual relationship records for canvas connections
    setIsSyncing(true)
    try {
      await syncCanvasConnectionsToDatabase()
    } finally {
      setIsSyncing(false)
    }
    
    onSave?.(canvasData)
  }

  // Sync canvas connections to database relationship records
  const syncCanvasConnectionsToDatabase = async () => {
    if (!projectId) return

    try {
      const supabase = createSupabaseClient()

      // Create actual relationship records for each connection
      for (const connection of connections) {
        const fromNode = nodes.find(n => n.id === connection.fromNodeId)
        const toNode = nodes.find(n => n.id === connection.toNodeId)
        
        if (!fromNode || !toNode) continue

        // Check if this relationship already exists
        const { data: existingRel } = await supabase
          .from('world_elements')
          .select('id')
          .eq('project_id', projectId)
          .eq('category', 'relationships')
          .or(`and(attributes->>character_1_id.eq.${fromNode.id},attributes->>character_2_id.eq.${toNode.id}),and(attributes->>character_1_id.eq.${toNode.id},attributes->>character_2_id.eq.${fromNode.id})`)
          .single()

        if (!existingRel) {
          // Create new relationship record
          const relationshipData = {
            name: `${fromNode.name} ↔ ${toNode.name}`,
            description: `${connection.label || 'Connected'} relationship between ${fromNode.name} and ${toNode.name}`,
            category: 'relationships',
            project_id: projectId,
            attributes: {
              type: connection.type || 'relationship',
              character_1_id: fromNode.id,
              character_2_id: toNode.id,
              relationship_type: connection.label || 'Connected',
              canvas_connection_id: connection.id,
              strength: 3, // Default medium strength
              status: 'active',
              created_at: new Date().toISOString()
            },
            tags: ['canvas-generated', 'relationship']
          }

          const { data, error } = await supabase
            .from('world_elements')
            .insert(relationshipData)
            .select()
            .single()

          if (!error && data) {
            // Add to the relationships list in the parent component
            setRelationships(prev => [data, ...prev])
          }
        }
      }
    } catch (error) {
      console.error('Error syncing canvas connections to database:', error)
    }
  }

  // Get connection path with draw.io-like smart routing
  const getConnectionPath = (connection: CanvasConnection) => {
    const fromNode = nodes.find(n => n.id === connection.fromNodeId)
    const toNode = nodes.find(n => n.id === connection.toNodeId)
    
    if (!fromNode || !toNode) return ''
    
    // Get the optimal connection points (like draw.io)
    const { fromPoint, toPoint } = getOptimalConnectionPoints(fromNode, toNode)
    
    // Create smart curved path based on relative positions
    return createSmartConnectionPath(fromPoint, toPoint, fromNode, toNode)
  }

  // Get optimal connection points on node edges (draw.io style)
  const getOptimalConnectionPoints = (fromNode: CanvasNode, toNode: CanvasNode) => {
    const fromCenter = {
      x: fromNode.x + fromNode.width / 2,
      y: fromNode.y + fromNode.height / 2
    }
    const toCenter = {
      x: toNode.x + toNode.width / 2,
      y: toNode.y + toNode.height / 2
    }
    
    // Calculate relative position to determine best connection points
    const dx = toCenter.x - fromCenter.x
    const dy = toCenter.y - fromCenter.y
    
    // Determine which sides to connect (like draw.io logic)
    let fromPoint: { x: number, y: number, direction: string }
    let toPoint: { x: number, y: number, direction: string }
    
    const absX = Math.abs(dx)
    const absY = Math.abs(dy)
    
    // Smart connection point selection
    if (absX > absY) {
      // Horizontal connection preferred
      if (dx > 0) {
        // From left to right
        fromPoint = {
          x: fromNode.x + fromNode.width,
          y: fromNode.y + fromNode.height / 2,
          direction: 'right'
        }
        toPoint = {
          x: toNode.x,
          y: toNode.y + toNode.height / 2,
          direction: 'left'
        }
      } else {
        // From right to left
        fromPoint = {
          x: fromNode.x,
          y: fromNode.y + fromNode.height / 2,
          direction: 'left'
        }
        toPoint = {
          x: toNode.x + toNode.width,
          y: toNode.y + toNode.height / 2,
          direction: 'right'
        }
      }
    } else {
      // Vertical connection preferred
      if (dy > 0) {
        // From top to bottom
        fromPoint = {
          x: fromNode.x + fromNode.width / 2,
          y: fromNode.y + fromNode.height,
          direction: 'bottom'
        }
        toPoint = {
          x: toNode.x + toNode.width / 2,
          y: toNode.y,
          direction: 'top'
        }
      } else {
        // From bottom to top
        fromPoint = {
          x: fromNode.x + fromNode.width / 2,
          y: fromNode.y,
          direction: 'top'
        }
        toPoint = {
          x: toNode.x + toNode.width / 2,
          y: toNode.y + toNode.height,
          direction: 'bottom'
        }
      }
    }
    
    return { fromPoint, toPoint }
  }

  // Create smart curved path (draw.io style)
  const createSmartConnectionPath = (
    fromPoint: { x: number, y: number, direction: string }, 
    toPoint: { x: number, y: number, direction: string },
    fromNode: CanvasNode,
    toNode: CanvasNode
  ) => {
    const distance = Math.sqrt(
      Math.pow(toPoint.x - fromPoint.x, 2) + 
      Math.pow(toPoint.y - fromPoint.y, 2)
    )
    
    // Control point distance (adaptive based on distance and direction)
    const controlDistance = Math.min(distance * 0.4, 100)
    
    // Calculate control points based on connection directions
    const controlPoint1 = getControlPoint(fromPoint, controlDistance)
    const controlPoint2 = getControlPoint(toPoint, controlDistance, true)
    
    // Create cubic bezier curve
    return `M ${fromPoint.x} ${fromPoint.y} C ${controlPoint1.x} ${controlPoint1.y}, ${controlPoint2.x} ${controlPoint2.y}, ${toPoint.x} ${toPoint.y}`
  }

  // Get control point for smooth curves
  const getControlPoint = (
    point: { x: number, y: number, direction: string }, 
    distance: number, 
    reverse = false
  ) => {
    const multiplier = reverse ? -1 : 1
    
    switch (point.direction) {
      case 'right':
        return { x: point.x + distance * multiplier, y: point.y }
      case 'left':
        return { x: point.x - distance * multiplier, y: point.y }
      case 'bottom':
        return { x: point.x, y: point.y + distance * multiplier }
      case 'top':
        return { x: point.x, y: point.y - distance * multiplier }
      default:
        return { x: point.x + distance * multiplier, y: point.y }
    }
  }

  return (
    <div className="flex h-full bg-gradient-to-br from-slate-50 to-gray-100 rounded-xl shadow-lg border border-gray-200/80 overflow-hidden">
      {/* Enhanced Elements Panel */}
      {showElementsPanel && (
        <div className="w-80 bg-white/90 backdrop-blur-sm border-r border-gray-200/60 overflow-y-auto">
          <div className="p-4 border-b border-gray-200/60 bg-gradient-to-r from-blue-50 to-indigo-50">
            <h3 className="text-lg font-semibold text-gray-900 flex items-center">
              <Users className="w-5 h-5 mr-2 text-blue-600" />
              Add Elements
            </h3>
            <p className="text-sm text-gray-600 mt-1">Click characters to add them to the canvas</p>
          </div>
          
          <div className="p-4 space-y-4">
            <div>
              <h4 className="font-medium text-gray-900 mb-3 flex items-center">
                <UserCircle className="w-4 h-4 mr-2 text-gray-500" />
                Characters
              </h4>
              <div className="space-y-2">
                {characters.map((character: any) => {
                  const isOnCanvas = nodes.some(node => node.id === character.id)
                  return (
                    <div
                      key={character.id}
                      onClick={() => addCharacterToCanvas(character)}
                      className={cn(
                        "group flex items-center gap-3 p-3 rounded-xl border transition-all duration-200",
                        isOnCanvas 
                          ? "border-green-300 bg-green-50/50 cursor-default" 
                          : "border-gray-200/60 hover:border-blue-300 hover:bg-gradient-to-r hover:from-blue-50/50 hover:to-indigo-50/50 cursor-pointer hover:shadow-sm hover:scale-[1.02]"
                      )}
                    >
                      <div className={cn(
                        "w-12 h-12 rounded-xl flex items-center justify-center text-sm font-semibold shadow-sm transition-shadow",
                        isOnCanvas
                          ? "bg-gradient-to-br from-green-100 to-emerald-100 text-green-700 group-hover:shadow-md"
                          : "bg-gradient-to-br from-blue-100 to-indigo-100 text-blue-700 group-hover:shadow-md"
                      )}>
                        {character.name.charAt(0).toUpperCase()}
                      </div>
                      <div className="flex-1">
                        <span className="font-medium text-gray-900 block">{character.name}</span>
                        <span className={cn(
                          "text-xs",
                          isOnCanvas ? "text-green-600" : "text-gray-500"
                        )}>
                          {isOnCanvas ? "On Canvas" : "Character"}
                        </span>
                      </div>
                      {isOnCanvas ? (
                        <CheckCircle className="w-4 h-4 text-green-500" />
                      ) : (
                        <Plus className="w-4 h-4 text-gray-400 group-hover:text-blue-500 transition-colors" />
                      )}
                    </div>
                  )
                })}
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Main Canvas Area */}
      <div className="flex-1 flex flex-col">
        {/* Header */}
        <div className="bg-white border-b px-6 py-4 flex items-center justify-between">
          <div>
            <h2 className="text-xl font-semibold text-gray-900">{relationshipName}</h2>
            <p className="text-sm text-gray-600">
              Visual Relationship Editor • {nodes.length} characters • {connections.length} connections
              {moveToolActive && <span className="text-blue-600 ml-2">🔧 Move tool active</span>}
              {isConnecting && <span className="text-purple-600 ml-2">🔗 Connection mode active</span>}
              {isPanning && <span className="text-green-600 ml-2">🖐️ Panning...</span>}
              {isSyncing && <span className="text-green-600 ml-2">💾 Syncing connections...</span>}
            </p>
          </div>
          
          <div className="flex items-center gap-3">
            <Button
              variant={moveToolActive ? "default" : "outline"}
              onClick={() => setMoveToolActive(!moveToolActive)}
              className={moveToolActive ? "bg-blue-600 hover:bg-blue-700 text-white" : "border-gray-300"}
              title="Move Tool - Click and drag to pan the canvas (Ctrl+M)"
            >
              <Move className="w-4 h-4 mr-2" />
              Move
            </Button>
            
            <Button
              variant={isConnecting ? "default" : "outline"}
              onClick={toggleConnectionMode}
              className={isConnecting ? "bg-purple-600 hover:bg-purple-700 text-white" : "border-gray-300"}
              title="Connection Tool - Click nodes to connect them (Ctrl+C)"
            >
              <Link2 className="w-4 h-4 mr-2" />
              Connect
            </Button>
            
            <Button
              variant={showElementsPanel ? "default" : "outline"}
              onClick={() => setShowElementsPanel(!showElementsPanel)}
              className="border-gray-300"
            >
              <Layers className="w-4 h-4 mr-2" />
              Elements
            </Button>
            
            <Button
              variant={showPropertiesPanel ? "default" : "outline"}
              onClick={togglePropertiesPanel}
              className="border-gray-300"
              title="Connection Properties Panel"
            >
              <Settings className="w-4 h-4 mr-2" />
              Properties
            </Button>
            
            <div className="flex items-center gap-1 border rounded-lg">
              <Button variant="ghost" size="sm" onClick={zoomOut}>
                <span className="text-lg">-</span>
              </Button>
              <span className="px-3 text-sm font-medium">{Math.round(scale * 100)}%</span>
              <Button variant="ghost" size="sm" onClick={zoomIn}>
                <span className="text-lg">+</span>
              </Button>
            </div>
            
            <Button variant="outline" onClick={resetZoom}>
              <RotateCcw className="w-4 h-4" />
            </Button>
            
            <Button onClick={handleSave} className="bg-green-600 hover:bg-green-700 text-white" disabled={isSyncing}>
              <Save className="w-4 h-4 mr-2" />
              {isSyncing ? 'Saving...' : 'Save'}
            </Button>
            
            <Button variant="outline" onClick={onClose}>
              <X className="w-4 h-4" />
            </Button>
          </div>
        </div>

        {/* Enhanced Canvas */}
        <div className="flex-1 relative overflow-hidden bg-gradient-to-br from-gray-50 via-blue-50/20 to-indigo-50/30">
          <div
            ref={canvasRef}
            className="w-full h-full relative cursor-move"
            style={{
              transform: `scale(${scale})`,
              transformOrigin: 'center center'
            }}
            onMouseDown={handleCanvasMouseDown}
            onMouseMove={handleMouseMove}
            onMouseUp={handleMouseUp}
            onContextMenu={(e) => e.preventDefault()}
            onClick={(e) => {
              // Clear selection if clicking on canvas background (not on nodes or buttons)
              const target = e.target as HTMLElement
              const isNode = target.closest('[data-node-id]')
              const isButton = target.closest('button')
              
              if (!isNode && !isButton) {
                setSelectedNode(null)
              }
            }}
          >
            {/* Enhanced Grid Background */}
            <div className="absolute inset-0 opacity-30 pointer-events-none">
              <svg width="100%" height="100%">
                <defs>
                  <pattern id="enhanced-grid" width="30" height="30" patternUnits="userSpaceOnUse">
                    <path d="M 30 0 L 0 0 0 30" fill="none" stroke="#e2e8f0" strokeWidth="1"/>
                    <circle cx="0" cy="0" r="1" fill="#cbd5e1" opacity="0.5"/>
                  </pattern>
                  <radialGradient id="grid-fade" cx="50%" cy="50%" r="50%">
                    <stop offset="0%" stopColor="white" stopOpacity="0"/>
                    <stop offset="100%" stopColor="white" stopOpacity="0.3"/>
                  </radialGradient>
                </defs>
                <rect width="100%" height="100%" fill="url(#enhanced-grid)" />
                <rect width="100%" height="100%" fill="url(#grid-fade)" />
              </svg>
            </div>

            {/* Connection Lines */}
            <svg 
              key={`connections-${connections.length}-${connections.map(c => `${c.id}-${c.hasArrow}-${c.hasReverseArrow}`).join('-')}`}
              className="absolute inset-0" 
              style={{ 
                zIndex: 1, 
                pointerEvents: 'none',
                shapeRendering: 'geometricPrecision',
                textRendering: 'geometricPrecision'
              }}
            >
              {/* Debug info */}
              <text x="10" y="30" fill="red" fontSize="12">
                Connections: {connections.length} | Nodes: {nodes.length}
              </text>
              {connections.length > 0 && (
                <text x="10" y="50" fill="red" fontSize="10">
                  First connection: {connections[0]?.id} ({connections[0]?.fromNodeId} → {connections[0]?.toNodeId})
                </text>
              )}
              <defs>
                {/* Enhanced connection styling */}
                <filter id="connection-glow" x="-50%" y="-50%" width="200%" height="200%">
                  <feMorphology operator="dilate" radius="1"/>
                  <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
                  <feMerge> 
                    <feMergeNode in="coloredBlur"/>
                    <feMergeNode in="SourceGraphic"/> 
                  </feMerge>
                </filter>
                
                {/* Professional gradient */}
                <linearGradient id="connection-gradient" x1="0%" y1="0%" x2="100%" y2="0%">
                  <stop offset="0%" stopColor="currentColor" stopOpacity="0.8"/>
                  <stop offset="50%" stopColor="currentColor" stopOpacity="1"/>
                  <stop offset="100%" stopColor="currentColor" stopOpacity="0.8"/>
                </linearGradient>
                
                {/* Arrow markers */}
                <marker
                  id="arrowhead"
                  markerWidth="10"
                  markerHeight="10" 
                  refX="9"
                  refY="5"
                  orient="auto"
                  markerUnits="strokeWidth"
                >
                  <path
                    d="M 0,0 L 0,10 L 10,5 z"
                    fill="currentColor"
                  />
                </marker>
                <marker
                  id="arrowhead-reverse"
                  markerWidth="10"
                  markerHeight="10"
                  refX="1"
                  refY="5"
                  orient="auto"
                  markerUnits="strokeWidth"
                >
                  <path
                    d="M 10,0 L 10,10 L 0,5 z"
                    fill="currentColor"
                  />
                </marker>
                <marker
                  id="arrowhead-selected"
                  markerWidth="12"
                  markerHeight="12"
                  refX="10"
                  refY="6"
                  orient="auto"
                  markerUnits="strokeWidth"
                >
                  <path
                    d="M 0,0 L 0,12 L 12,6 z"
                    fill="#7c3aed"
                  />
                </marker>
                <marker
                  id="arrowhead-reverse-selected"
                  markerWidth="12"
                  markerHeight="12"
                  refX="2"
                  refY="6"
                  orient="auto"
                  markerUnits="strokeWidth"
                >
                  <path
                    d="M 12,0 L 12,12 L 0,6 z"
                    fill="#7c3aed"
                  />
                </marker>
              </defs>
              {connections.map(connection => {
                console.log('Rendering connection:', connection)
                console.log('Available nodes:', nodes.map(n => ({ id: n.id, x: n.x, y: n.y, width: n.width, height: n.height })))
                
                const isSelected = selectedConnection === connection.id
                
                // Get path data
                const pathData = getConnectionPath(connection)
                console.log('Path data for connection', connection.id, ':', pathData)
                if (!pathData) {
                  console.warn('No path data generated for connection:', connection.id)
                  return null
                }
                
                console.log('🔍 CANVAS RENDER DEBUG:', {
                  connectionsLength: connections.length,
                  connectionsData: connections,
                  nodesLength: nodes.length,
                  nodesData: nodes.map(n => ({ id: n.id, x: n.x, y: n.y, width: n.width, height: n.height })),
                  selectedConnection,
                  showAnimations,
                  animationSpeed
                })
                
                const fromNode = nodes.find(n => n.id === connection.fromNodeId)
                const toNode = nodes.find(n => n.id === connection.toNodeId)
                if (!fromNode || !toNode) {
                  console.warn('Missing nodes for connection:', connection.id, { fromNode: !!fromNode, toNode: !!toNode })
                  return null
                }

                // Get connection points for label positioning
                const { fromPoint, toPoint } = getOptimalConnectionPoints(fromNode, toNode)
                const midX = (fromPoint.x + toPoint.x) / 2
                const midY = (fromPoint.y + toPoint.y) / 2
                
                const strokeWidth = connection.strokeWidth || 3
                
                return (
                  <g key={connection.id} className={isSelected ? 'connection-selected' : ''}>
                    {/* Debug: Simple visible line first */}
                    <line
                      x1={fromPoint.x}
                      y1={fromPoint.y}
                      x2={toPoint.x}
                      y2={toPoint.y}
                      stroke="red"
                      strokeWidth="5"
                      opacity="1"
                      strokeDasharray="10,5"
                    />
                    
                    {/* Debug: Another simple path to test SVG rendering */}
                    <path
                      d={pathData}
                      stroke="blue"
                      strokeWidth="4"
                      fill="none"
                      opacity="1"
                    />
                    
                    {/* Debug: Circle at connection points */}
                    <circle cx={fromPoint.x} cy={fromPoint.y} r="8" fill="green" opacity="0.8" />
                    <circle cx={toPoint.x} cy={toPoint.y} r="8" fill="orange" opacity="0.8" />
                    
                    {/* Debug: Text label to confirm rendering */}
                    <text x={midX} y={midY} fill="purple" fontSize="14" textAnchor="middle">
                      CONNECTION VISIBLE
                    </text>
                  </g>
                )
              })}
            </svg>

            {/* Enhanced Character Nodes */}
            {nodes.map(node => (
              <div
                key={node.id}
                data-node-id={node.id}
                className={cn(
                  "absolute bg-gradient-to-br from-white via-white to-gray-50 rounded-2xl shadow-lg border-2 cursor-move select-none group transition-all duration-200",
                  selectedNode === node.id 
                    ? "border-blue-400 shadow-blue-200/50 shadow-xl scale-105" 
                    : "border-gray-200/80 hover:border-blue-300 hover:shadow-xl hover:scale-102",
                  "backdrop-blur-sm"
                )}
                style={{
                  left: node.x,
                  top: node.y,
                  width: node.width,
                  height: node.height
                }}
                onMouseDown={(e) => handleNodeMouseDown(node.id, e)}
                onClick={(e) => handleNodeClick(node.id, e)}
              >
                {/* Card Background with Gradient Overlay */}
                <div className="absolute inset-0 bg-gradient-to-br from-blue-50/30 via-transparent to-indigo-50/30 rounded-2xl opacity-0 group-hover:opacity-100 transition-opacity duration-200" />
                
                <div className="relative p-4 h-full flex items-center justify-center">
                  <div className="text-center">
                    {/* Enhanced Avatar */}
                    <div className="relative w-12 h-12 mx-auto mb-3">
                      <div className="w-full h-full bg-gradient-to-br from-blue-100 via-indigo-100 to-purple-100 rounded-full flex items-center justify-center text-lg font-bold text-blue-700 shadow-md group-hover:shadow-lg transition-shadow">
                        {node.name.charAt(0).toUpperCase()}
                      </div>
                      {/* Avatar Ring */}
                      <div className="absolute inset-0 rounded-full border-2 border-white shadow-sm group-hover:border-blue-200 transition-colors" />
                      {/* Pulse Effect for Selected */}
                      {selectedNode === node.id && (
                        <div className="absolute inset-0 rounded-full border-2 border-blue-400 animate-pulse" />
                      )}
                    </div>
                    
                    {/* Enhanced Name */}
                    <div className="mb-1">
                      <span className="text-sm font-semibold text-gray-900 block leading-tight">
                        {node.name}
                      </span>
                    </div>
                    
                    {/* Enhanced Type Badge */}
                    <div className="inline-flex items-center px-2 py-1 rounded-full bg-gradient-to-r from-blue-100 to-indigo-100 text-xs font-medium text-blue-700 border border-blue-200/50">
                      <UserCircle className="w-3 h-3 mr-1" />
                      {node.type}
                    </div>
                  </div>
                </div>

                {/* Enhanced Node Actions */}
                {selectedNode === node.id && (
                  <div className="absolute -top-4 -right-4 flex gap-1 z-50">
                    <Button
                      size="sm"
                      className="w-10 h-10 p-0 bg-gradient-to-r from-blue-500 to-blue-600 hover:from-blue-600 hover:to-blue-700 text-white border-2 border-white shadow-lg hover:shadow-xl transition-all duration-200 rounded-full"
                      onClick={(e) => {
                        e.stopPropagation()
                        e.preventDefault()
                        toggleConnectionMode()
                        setConnectionStart(node.id)
                      }}
                      title="Create Connection"
                    >
                      <Link2 className="w-4 h-4" />
                    </Button>
                    <Button
                      size="sm"
                      className="w-10 h-10 p-0 bg-gradient-to-r from-red-500 to-red-600 hover:from-red-600 hover:to-red-700 text-white border-2 border-white shadow-lg hover:shadow-xl transition-all duration-200 rounded-full"
                      onClick={(e) => {
                        e.stopPropagation()
                        e.preventDefault()
                        deleteNode(node.id)
                      }}
                      title="Delete Node"
                    >
                      <Trash2 className="w-4 h-4" />
                    </Button>
                  </div>
                )}

                {/* Draw.io Style Connection Ports */}
                {(selectedNode === node.id || isConnecting) && (
                  <>
                    {/* Top Connection Port */}
                    <div
                      className={cn(
                        "absolute w-3 h-3 bg-blue-500 border-2 border-white rounded-full shadow-md cursor-crosshair z-40 transition-all duration-200",
                        "left-1/2 -translate-x-1/2 -top-1.5",
                        isConnecting ? "scale-125 animate-pulse" : "hover:scale-110"
                      )}
                      onClick={(e) => {
                        e.stopPropagation()
                        e.preventDefault()
                        if (isConnecting && connectionStart && connectionStart !== node.id) {
                          // Create new connection
                          const newConnection: CanvasConnection = {
                            id: `${connectionStart}-${node.id}-${Date.now()}`,
                            fromNodeId: connectionStart,
                            toNodeId: node.id,
                            label: 'New Relationship',
                            type: 'friendship',
                            color: '#10b981',
                            hasArrow: true,
                            isDirectional: false,
                            strokeWidth: 2
                          }
                          setConnections(prev => [...prev, newConnection])
                          setIsConnecting(false)
                          setConnectionStart(null)
                        } else if (!isConnecting) {
                          setIsConnecting(true)
                          setConnectionStart(node.id)
                        }
                      }}
                      title="Connect from top"
                    />
                    
                    {/* Right Connection Port */}
                    <div
                      className={cn(
                        "absolute w-3 h-3 bg-blue-500 border-2 border-white rounded-full shadow-md cursor-crosshair z-40 transition-all duration-200",
                        "top-1/2 -translate-y-1/2 -right-1.5",
                        isConnecting ? "scale-125 animate-pulse" : "hover:scale-110"
                      )}
                      onClick={(e) => {
                        e.stopPropagation()
                        e.preventDefault()
                        if (isConnecting && connectionStart && connectionStart !== node.id) {
                          const newConnection: CanvasConnection = {
                            id: `${connectionStart}-${node.id}-${Date.now()}`,
                            fromNodeId: connectionStart,
                            toNodeId: node.id,
                            label: 'New Relationship',
                            type: 'friendship',
                            color: '#10b981',
                            hasArrow: true,
                            isDirectional: false,
                            strokeWidth: 2
                          }
                          setConnections(prev => [...prev, newConnection])
                          setIsConnecting(false)
                          setConnectionStart(null)
                        } else if (!isConnecting) {
                          setIsConnecting(true)
                          setConnectionStart(node.id)
                        }
                      }}
                      title="Connect from right"
                    />
                    
                    {/* Bottom Connection Port */}
                    <div
                      className={cn(
                        "absolute w-3 h-3 bg-blue-500 border-2 border-white rounded-full shadow-md cursor-crosshair z-40 transition-all duration-200",
                        "left-1/2 -translate-x-1/2 -bottom-1.5",
                        isConnecting ? "scale-125 animate-pulse" : "hover:scale-110"
                      )}
                      onClick={(e) => {
                        e.stopPropagation()
                        e.preventDefault()
                        if (isConnecting && connectionStart && connectionStart !== node.id) {
                          const newConnection: CanvasConnection = {
                            id: `${connectionStart}-${node.id}-${Date.now()}`,
                            fromNodeId: connectionStart,
                            toNodeId: node.id,
                            label: 'New Relationship',
                            type: 'friendship',
                            color: '#10b981',
                            hasArrow: true,
                            isDirectional: false,
                            strokeWidth: 2
                          }
                          setConnections(prev => [...prev, newConnection])
                          setIsConnecting(false)
                          setConnectionStart(null)
                        } else if (!isConnecting) {
                          setIsConnecting(true)
                          setConnectionStart(node.id)
                        }
                      }}
                      title="Connect from bottom"
                    />
                    
                    {/* Left Connection Port */}
                    <div
                      className={cn(
                        "absolute w-3 h-3 bg-blue-500 border-2 border-white rounded-full shadow-md cursor-crosshair z-40 transition-all duration-200",
                        "top-1/2 -translate-y-1/2 -left-1.5",
                        isConnecting ? "scale-125 animate-pulse" : "hover:scale-110"
                      )}
                      onClick={(e) => {
                        e.stopPropagation()
                        e.preventDefault()
                        if (isConnecting && connectionStart && connectionStart !== node.id) {
                          const newConnection: CanvasConnection = {
                            id: `${connectionStart}-${node.id}-${Date.now()}`,
                            fromNodeId: connectionStart,
                            toNodeId: node.id,
                            label: 'New Relationship',
                            type: 'friendship',
                            color: '#10b981',
                            hasArrow: true,
                            isDirectional: false,
                            strokeWidth: 2
                          }
                          setConnections(prev => [...prev, newConnection])
                          setIsConnecting(false)
                          setConnectionStart(null)
                        } else if (!isConnecting) {
                          setIsConnecting(true)
                          setConnectionStart(node.id)
                        }
                      }}
                      title="Connect from left"
                    />
                  </>
                )}

                {/* Connection Indicator */}
                {isConnecting && connectionStart && (
                  <div className="absolute inset-0 rounded-2xl border-2 border-dashed border-blue-400 bg-blue-50/50 animate-pulse" />
                )}
              </div>
            ))}

            {/* Enhanced Connection Guide */}
            {isConnecting && (
              <div className="absolute top-6 left-1/2 transform -translate-x-1/2 bg-gradient-to-r from-blue-100 to-indigo-100 text-blue-800 px-6 py-3 rounded-2xl shadow-lg text-sm font-medium border border-blue-200/50 backdrop-blur-sm">
                <div className="flex items-center">
                  <div className="w-3 h-3 bg-blue-500 rounded-full animate-pulse mr-3" />
                  Click on another character to create a connection
                </div>
              </div>
            )}

            {/* Empty State */}
            {nodes.length === 0 && (
              <div className="absolute top-6 left-1/2 transform -translate-x-1/2 bg-white/95 backdrop-blur-sm rounded-xl shadow-lg border border-gray-200/60 px-4 py-2">
                <div className="flex items-center gap-2 text-sm text-gray-600">
                  <ZoomIn className="w-4 h-4 text-gray-500" />
                  <span>Use mouse wheel to zoom • Add characters to get started</span>
                </div>
              </div>
            )}

            {/* Connection count and database sync info */}
            {connections.length > 0 && !isConnecting && !selectedConnection && (
              <div className="absolute top-16 right-6 bg-white/90 backdrop-blur-sm rounded-lg shadow-sm border border-gray-200 px-3 py-2">
                <div className="text-xs text-gray-600">
                  {connections.length} connection{connections.length !== 1 ? 's' : ''} on canvas
                  <div className="text-xs text-gray-500 mt-1">
                    Save to sync with database
                  </div>
                </div>
              </div>
            )}

            {/* Selected Connection Info */}
            {selectedConnection && (
              <div className="absolute bottom-6 left-1/2 transform -translate-x-1/2 bg-white backdrop-blur-sm rounded-xl shadow-lg border border-gray-200 px-4 py-3">
                <div className="flex items-center gap-3">
                  <div className="flex items-center gap-2 text-sm text-gray-700">
                    <Link2 className="w-4 h-4" />
                    <span>Connection selected</span>
                  </div>
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => deleteConnection(selectedConnection)}
                    className="text-red-600 border-red-200 hover:bg-red-50"
                  >
                    <Trash2 className="w-3 h-3 mr-1" />
                    Delete
                  </Button>
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => setSelectedConnection(null)}
                  >
                    Cancel
                  </Button>
                </div>
              </div>
            )}
          </div>
        </div>
      </div>

      {/* Properties Panel */}
      {showPropertiesPanel && selectedConnection && (
        <div className="w-80 bg-white border-l border-gray-200 flex flex-col">
          <div className="p-4 border-b border-gray-200">
            <div className="flex items-center justify-between">
              <h3 className="font-semibold text-gray-900">Arrow Configuration</h3>
              <Button
                variant="ghost"
                size="sm"
                onClick={() => setShowPropertiesPanel(false)}
              >
                <X className="w-4 h-4" />
              </Button>
            </div>
          </div>
          
          <div className="flex-1 overflow-y-auto p-4">
            {(() => {
              const connection = connections.find(c => c.id === selectedConnection)
              if (!connection) return null

              return (
                <div className="space-y-6">
                  {/* Direction */}
                  <div>
                    <h4 className="text-sm font-medium text-gray-700 mb-3">Direction</h4>
                    <div className="grid grid-cols-3 gap-2">
                      <Button
                        variant={connection.hasArrow && !connection.hasReverseArrow ? "default" : "outline"}
                        size="sm"
                        onClick={() => updateConnectionProperties(connection.id, { hasArrow: false, hasReverseArrow: false })}
                        className="flex flex-col items-center gap-1 h-12"
                      >
                        <div className="w-8 h-0.5 bg-gray-400"></div>
                        <span className="text-xs">None</span>
                      </Button>
                      <Button
                        variant={connection.hasArrow && !connection.hasReverseArrow ? "default" : "outline"}
                        size="sm"
                        onClick={() => updateConnectionProperties(connection.id, { hasArrow: true, hasReverseArrow: false })}
                        className="flex flex-col items-center gap-1 h-12"
                      >
                        <div className="flex items-center">
                          <div className="w-6 h-0.5 bg-gray-400"></div>
                          <div className="w-2 h-2 bg-gray-400 rotate-45 transform origin-left -ml-1"></div>
                        </div>
                        <span className="text-xs">Forward</span>
                      </Button>
                      <Button
                        variant={connection.hasArrow && connection.hasReverseArrow ? "default" : "outline"}
                        size="sm"
                        onClick={() => updateConnectionProperties(connection.id, { hasArrow: true, hasReverseArrow: true })}
                        className="flex flex-col items-center gap-1 h-12"
                      >
                        <div className="flex items-center">
                          <div className="w-2 h-2 bg-gray-400 rotate-45 transform origin-right -mr-1"></div>
                          <div className="w-4 h-0.5 bg-gray-400"></div>
                          <div className="w-2 h-2 bg-gray-400 rotate-45 transform origin-left -ml-1"></div>
                        </div>
                        <span className="text-xs">Both</span>
                      </Button>
                    </div>
                  </div>

                  {/* Forward Arrow Configuration */}
                  {connection.hasArrow && (
                    <div>
                      <h4 className="text-sm font-medium text-purple-700 mb-3 flex items-center gap-2">
                        <ArrowRight className="w-4 h-4" />
                        Forward Arrow
                      </h4>
                      
                      {/* Size */}
                      <div className="mb-4">
                        <label className="text-xs text-gray-600 mb-2 block">Size</label>
                        <div className="flex items-center gap-3">
                          <span className="text-xs text-gray-500">Small</span>
                          <input
                            type="range"
                            min="6"
                            max="20"
                            value={connection.arrowSize || 10}
                            onChange={(e) => updateConnectionProperties(connection.id, { arrowSize: parseInt(e.target.value) })}
                            className="flex-1 h-2 bg-purple-200 rounded-lg appearance-none cursor-pointer"
                          />
                          <span className="text-xs text-gray-500">Large</span>
                        </div>
                      </div>

                      {/* Color */}
                      <div className="mb-4">
                        <label className="text-xs text-gray-600 mb-2 block">Color</label>
                        <div className="grid grid-cols-7 gap-1">
                          {['#f97316', '#3b82f6', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6', '#ec4899'].map(color => (
                            <button
                              key={color}
                              onClick={() => updateConnectionProperties(connection.id, { arrowColor: color, color: color })}
                              className={cn(
                                "w-8 h-8 rounded border-2",
                                connection.arrowColor === color || connection.color === color ? "border-gray-400" : "border-transparent"
                              )}
                              style={{ backgroundColor: color }}
                            />
                          ))}
                        </div>
                      </div>
                    </div>
                  )}

                  {/* Line Style */}
                  <div>
                    <h4 className="text-sm font-medium text-gray-700 mb-3">Line Style</h4>
                    
                    {/* Line Color */}
                    <div className="mb-4">
                      <label className="text-xs text-gray-600 mb-2 block">Line Color</label>
                      <div className="grid grid-cols-5 gap-2">
                        {[
                          { color: '#10b981', name: 'Green' },
                          { color: '#ef4444', name: 'Red' }, 
                          { color: '#f97316', name: 'Orange' },
                          { color: '#3b82f6', name: 'Blue' },
                          { color: '#8b5cf6', name: 'Purple' }
                        ].map(({ color, name }) => (
                          <button
                            key={color}
                            onClick={() => updateConnectionProperties(connection.id, { color, arrowColor: color })}
                            className={cn(
                              "p-2 rounded border-2 text-xs",
                              connection.color === color ? "border-gray-400 bg-gray-50" : "border-gray-200"
                            )}
                          >
                            <div className="w-full h-1 rounded mb-1" style={{ backgroundColor: color }}></div>
                            {name}
                          </button>
                        ))}
                      </div>
                    </div>

                    {/* Connection Label */}
                    <div className="mb-4">
                      <label className="text-xs text-gray-600 mb-2 block">Label</label>
                      <Input
                        value={connection.label || ''}
                        onChange={(e) => updateConnectionProperties(connection.id, { label: e.target.value })}
                        placeholder="Connection label..."
                        className="text-sm"
                      />
                    </div>
                  </div>
                </div>
              )
            })()}
          </div>
        </div>
      )}
    </div>
  )
}

export default RelationshipsPanel

